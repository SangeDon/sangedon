<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Sange</title>
  
  <subtitle>心即理</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.sangedon.cn/"/>
  <updated>2020-09-23T16:06:34.055Z</updated>
  <id>http://blog.sangedon.cn/</id>
  
  <author>
    <name>董先生</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Mac下K8S环境搭建</title>
    <link href="http://blog.sangedon.cn/paper/Mac%E4%B8%8BK8S%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>http://blog.sangedon.cn/paper/Mac下K8S环境搭建/</id>
    <published>2020-06-23T01:50:12.000Z</published>
    <updated>2020-09-23T16:06:34.055Z</updated>
    
    <content type="html"><![CDATA[<h2 id="搭建K8S环境"><a href="#搭建K8S环境" class="headerlink" title="搭建K8S环境"></a>搭建K8S环境</h2><p>参考文档：<a href="https://github.com/AliyunContainerService/k8s-for-docker-desktop" target="_blank" rel="noopener">https://github.com/AliyunContainerService/k8s-for-docker-desktop</a></p><ol><li><h6 id="docker-已安装，版本为"><a href="#docker-已安装，版本为" class="headerlink" title="docker 已安装，版本为"></a>docker 已安装，版本为</h6><p><img src="/paper/Mac下K8S环境搭建/image-20200810214022444.png" alt="image-20200810214022444"></p></li><li><h6 id="下载和-Kubernetes-版本匹配的k8s相关依赖镜像资源，配置好docker-的阿里云或者中科大的镜像加速"><a href="#下载和-Kubernetes-版本匹配的k8s相关依赖镜像资源，配置好docker-的阿里云或者中科大的镜像加速" class="headerlink" title="下载和 Kubernetes 版本匹配的k8s相关依赖镜像资源，配置好docker 的阿里云或者中科大的镜像加速"></a>下载和 Kubernetes 版本匹配的k8s相关依赖镜像资源，配置好docker 的阿里云或者中科大的镜像加速</h6></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 下载命令</span><br><span class="line">git clone git@github.com:AliyunContainerService/k8s-for-docker-desktop.git -b v1.16.5</span><br></pre></td></tr></table></figure><ol start="3"><li><h6 id="进入到下载的-k8s-for-docker-desktop-目录，执行如下命令"><a href="#进入到下载的-k8s-for-docker-desktop-目录，执行如下命令" class="headerlink" title="进入到下载的 k8s-for-docker-desktop 目录，执行如下命令"></a>进入到下载的 k8s-for-docker-desktop 目录，执行如下命令</h6></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./load_images.sh</span><br></pre></td></tr></table></figure><ol start="4"><li><h6 id="勾选如下，重启即可"><a href="#勾选如下，重启即可" class="headerlink" title="勾选如下，重启即可"></a>勾选如下，重启即可</h6><p><img src="/paper/Mac下K8S环境搭建/image-20200810215529829.png" alt="image-20200810215529829"></p></li></ol><ol start="5"><li><h6 id="部署-Kubernetes-dashboard（执行了第二条）"><a href="#部署-Kubernetes-dashboard（执行了第二条）" class="headerlink" title="部署 Kubernetes dashboard（执行了第二条）"></a>部署 Kubernetes dashboard（执行了第二条）</h6></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v2.0.0-rc5/aio/deploy/recommended.yaml</span><br><span class="line"><span class="meta">#</span> 或</span><br><span class="line">kubectl create -f kubernetes-dashboard.yaml</span><br></pre></td></tr></table></figure><ol start="6"><li>检查 kubernetes-dashboard 应用状态</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pod -n kubernetes-dashboard</span><br></pre></td></tr></table></figure><ol start="7"><li>开启 API Server 访问代理</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl proxy</span><br></pre></td></tr></table></figure><ol start="8"><li>进入k8s仪表盘</li></ol><p>链接：<a href="http://localhost:8001/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy/#/login" target="_blank" rel="noopener">http://localhost:8001/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy/#/login</a></p><ol start="9"><li>配置控制台访问令牌</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 获取登陆 token</span><br><span class="line">TOKEN=$(kubectl -n kube-system describe secret default| awk '$1=="token:"&#123;print $2&#125;')</span><br><span class="line">kubectl config set-credentials docker-for-desktop --token="$&#123;TOKEN&#125;"</span><br><span class="line">echo $TOKEN</span><br></pre></td></tr></table></figure><ul><li>token</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">User "docker-for-desktop" set.</span><br><span class="line">eyJhbGciOiJSUzI1NiIsImtpZCI6Ilp3bUthZkNlZzh3bWlsNDJoTkMxVS1nbm1RSU9TM1VPbXhDcURleG9WRnMifQ.eyJpc3MiOiJrdWJlcm5ldGVzL3NlcnZpY2VhY2NvdW50Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9uYW1lc3BhY2UiOiJrdWJlLXN5c3RlbSIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VjcmV0Lm5hbWUiOiJkZWZhdWx0LXRva2VuLWtmeDI3Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9zZXJ2aWNlLWFjY291bnQubmFtZSI6ImRlZmF1bHQiLCJrdWJlcm5ldGVzLmlvL3NlcnZpY2VhY2NvdW50L3NlcnZpY2UtYWNjb3VudC51aWQiOiIzMGM4MWU0OS1lY2QxLTQ1NjktOGY1Mi02OWZiNTMyOWNmYTgiLCJzdWIiOiJzeXN0ZW06c2VydmljZWFjY291bnQ6a3ViZS1zeXN0ZW06ZGVmYXVsdCJ9.uasjTbEU1YEnsYJZ48SK6RBZ9f-SNw9UWimAPe4VQ-2YBExruye04FFREPKXIQw6TJCQ83Vh35kNNXQgYVjEhPMFbgG1oASJZ1fskEul8lBVD2jh41Ul7xrIs4DhADAGpov8nHib7OHN7pkEh8h3UicRdOlYD6pYw2hFvxmHy_ZZwZ8WFXlOeKxh-VT9PYx_LMsNHcZzySO7sQMq7N3jQN7eI8ZFIhoXkA0PaSIb4L0FPYqY0OpwKth0KB6E0181CWUdJVlcICpATL8KPR8HobbGn6uTF5r6gLSX58af1bxGeK4JvKf2sypMcoOdr1s-AYJ8ur7-3E98XWoqsW7UZQ</span><br></pre></td></tr></table></figure><ul><li>安装 ingress失败解决方案</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 报错如下</span><br><span class="line">The connection to the server raw.githubusercontent.com was refused - did you specify the right host or port?</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 解决如下</span><br><span class="line">sudo vi /etc/hosts</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 添加如下配置即可解决</span><br><span class="line">151.101.76.133 raw.githubusercontent.com</span><br></pre></td></tr></table></figure><ul><li>安装kubesphere-minimal，参考：<a href="https://kubesphere.com.cn/docs/zh-CN/installation/prerequisites/" target="_blank" rel="noopener">https://kubesphere.com.cn/docs/zh-CN/installation/prerequisites/</a></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f https://raw.githubusercontent.com/kubesphere/ks-installer/master/kubesphere-minimal.yaml</span><br></pre></td></tr></table></figure><ul><li><p>安装helm</p><p>下载：<a href="https://github.com/helm/helm/releases" target="_blank" rel="noopener">https://github.com/helm/helm/releases</a></p><p>版本：2.16.2</p><p>解压下载的文件后将可执行文件helm添加到path</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mv helm /usr/local/bin/</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 验证安装</span><br><span class="line">helm version</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 输出</span><br><span class="line">Client: &amp;version.Version&#123;SemVer:"v2.16.2", GitCommit:"bbdfe5e7803a12bbdf97e94cd847859890cf4050", GitTreeState:"clean"&#125;</span><br></pre></td></tr></table></figure></li><li><p>初始化 helm 并安装 Tiller</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">helm init --upgrade -i registry.cn-hangzhou.aliyuncs.com/google_containers/tiller:v2.16.2 --stable-repo-url https://kubernetes.oss-cn-hangzhou.aliyuncs.com/charts</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;搭建K8S环境&quot;&gt;&lt;a href=&quot;#搭建K8S环境&quot; class=&quot;headerlink&quot; title=&quot;搭建K8S环境&quot;&gt;&lt;/a&gt;搭建K8S环境&lt;/h2&gt;&lt;p&gt;参考文档：&lt;a href=&quot;https://github.com/AliyunContainerSe
      
    
    </summary>
    
      <category term="环境搭建" scheme="http://blog.sangedon.cn/categories/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    
    
      <category term="docker" scheme="http://blog.sangedon.cn/tags/docker/"/>
    
      <category term="Mac" scheme="http://blog.sangedon.cn/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>Mac下安装virturebox及vagrant虚拟机环境</title>
    <link href="http://blog.sangedon.cn/paper/Mac%E4%B8%8B%E5%AE%89%E8%A3%85virturebox%E5%8F%8Avagrant%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%8E%AF%E5%A2%83/"/>
    <id>http://blog.sangedon.cn/paper/Mac下安装virturebox及vagrant虚拟机环境/</id>
    <published>2020-06-22T06:32:15.000Z</published>
    <updated>2020-09-23T16:06:36.179Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装virturebox"><a href="#安装virturebox" class="headerlink" title="安装virturebox"></a>安装virturebox</h2><p>下载：<a href="https://www.virtualbox.org/wiki/Downloads" target="_blank" rel="noopener">https://www.virtualbox.org/wiki/Downloads</a></p><p>版本：6.1.12</p><p>安装步骤：双击下一步即可</p><h2 id="安装vagrant"><a href="#安装vagrant" class="headerlink" title="安装vagrant"></a>安装vagrant</h2><p>下载：<a href="https://www.vagrantup.com/downloads.html" target="_blank" rel="noopener">https://www.vagrantup.com/downloads.html</a></p><p>版本：2.2.9</p><p>安装步骤：双击下一步即可</p><ul><li>虚拟机Box下载地址</li></ul><blockquote><p>官方虚拟机box下载地址：<a href="https://app.vagrantup.com/boxes/search" target="_blank" rel="noopener">https://app.vagrantup.com/boxes/search</a></p><p>仓库虚拟机box下载地址：<a href="http://www.vagrantbox.es/" target="_blank" rel="noopener">http://www.vagrantbox.es/</a></p></blockquote><h2 id="配置vagrant"><a href="#配置vagrant" class="headerlink" title="配置vagrant"></a>配置vagrant</h2><p>查看vagrant安装版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 输入</span><br><span class="line">vagrant -v</span><br><span class="line"><span class="meta">#</span> 输出</span><br><span class="line">Vagrant 2.2.9</span><br></pre></td></tr></table></figure><ul><li>检查已有的虚拟机列表vagrant box list，提示还没有任何虚拟机</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dongliangqiong@dongliaongdeMBP sangedon % vagrant box list</span><br><span class="line">There are no installed boxes! Use `vagrant box add` to add some.</span><br></pre></td></tr></table></figure><ul><li>将官网box下载下来的 <code>CentOS-7-x86_64-Vagrant-1902_01.VirtualBox.box</code>放入 <code>/Users/dongliangqiong/Documents/sangedon/devtools/software/vagrant</code>目录，后执行如下操作</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vagrant box add centos7 /Users/dongliangqiong/Documents/sangedon/devtools/software/vagrant/CentOS-7-x86_64-Vagrant-1902_01.VirtualBox.box</span><br></pre></td></tr></table></figure><ul><li>执行<code>vagrant init centos7</code>，即可在当前目录生成此虚拟机的配置文件Vagrantfile</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dongliangqiong@dongliaongdeMBP sangedon % vagrant init centos/7</span><br><span class="line">A `Vagrantfile` has been placed in this directory. You are now</span><br><span class="line">ready to `vagrant up` your first virtual environment! Please read</span><br><span class="line">the comments in the Vagrantfile as well as documentation on</span><br><span class="line">`vagrantup.com` for more information on using Vagrant.</span><br></pre></td></tr></table></figure><ul><li><p>执行命令<code>vagrant up</code>，启动虚拟机（参考：<a href="http://www.voidcn.com/article/p-zmehqqii-bdx.html）" target="_blank" rel="noopener">http://www.voidcn.com/article/p-zmehqqii-bdx.html）</a></p></li><li><p>链接虚拟机</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vagrant ssh</span><br></pre></td></tr></table></figure><ul><li>设置root用户登陆</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> vagrant登陆进去之后跳转root账户</span><br><span class="line">sudo -s</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 设置root账户账号</span><br><span class="line">passwd</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 修改 /etc/ssh/sshd_config 文件，下面两项改为yes</span><br><span class="line">PermitRootLogin yes</span><br><span class="line">PasswordAuthentication yes</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 重启服务</span><br><span class="line">service sshd restart</span><br></pre></td></tr></table></figure><blockquote><p>虚拟机创建成功，可通过 <code>ssh root@ip</code> 命令连接</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;安装virturebox&quot;&gt;&lt;a href=&quot;#安装virturebox&quot; class=&quot;headerlink&quot; title=&quot;安装virturebox&quot;&gt;&lt;/a&gt;安装virturebox&lt;/h2&gt;&lt;p&gt;下载：&lt;a href=&quot;https://www.virtua
      
    
    </summary>
    
      <category term="环境搭建" scheme="http://blog.sangedon.cn/categories/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    
    
      <category term="Mac" scheme="http://blog.sangedon.cn/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>Mac 电脑基础开发环境搭建</title>
    <link href="http://blog.sangedon.cn/paper/Mac-%E7%94%B5%E8%84%91%E5%9F%BA%E7%A1%80%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>http://blog.sangedon.cn/paper/Mac-电脑基础开发环境搭建/</id>
    <published>2020-06-12T05:19:17.000Z</published>
    <updated>2020-10-10T13:10:20.016Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h2><p>官网下载： <a href="https://www.git-scm.com/download/" target="_blank" rel="noopener">https://www.git-scm.com/download/</a></p><p>版本：<a href="https://sourceforge.net/projects/git-osx-installer/files/git-2.27.0-intel-universal-mavericks.dmg/download?use_mirror=autoselect" target="_blank" rel="noopener">2.27.0</a></p><p>安装：下载后双击 -&gt; 下一步即可</p><p>配置 git 账号</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config user.name "sangedon"</span><br><span class="line">git config user.email "sange.dong@outlook.com"</span><br></pre></td></tr></table></figure><h2 id="配置ssh"><a href="#配置ssh" class="headerlink" title="配置ssh"></a>配置ssh</h2><p>1 、检查.ssh文件夹是否存在</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -al ~/.ssh</span><br></pre></td></tr></table></figure><p>2、如果不存在新建.ssh文件平</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir ~/.ssh</span><br></pre></td></tr></table></figure><p>3、生成KEY在命令行中输入，<a href="mailto:sange.dong@outlook.com" target="_blank" rel="noopener">sange.dong@outlook.com</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ~/.ssh</span><br><span class="line">ssh-keygen -t rsa -C "sange.dong@outlook.com"</span><br></pre></td></tr></table></figure><p>系统提示输入文件保存位置等信息，连续按三次回车即可，生成的SSH key文件的保存路径会在终端中给出：id_rsa      id_rsa.pub</p><p>4、查看公钥</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat id_rsa.pub</span><br></pre></td></tr></table></figure><h2 id="安装-JDK1-8"><a href="#安装-JDK1-8" class="headerlink" title="安装 JDK1.8"></a>安装 JDK1.8</h2><p>下载Mac版jdk网址：<a href="https://www.oracle.com/java/technologies/javase/javase-jdk8-downloads.html" target="_blank" rel="noopener">https://www.oracle.com/java/technologies/javase/javase-jdk8-downloads.html</a></p><p>oracle下载登陆账号：<a href="mailto:2696671285@qq.com" target="_blank" rel="noopener">2696671285@qq.com</a> / Oracle123</p><p>下载的版本：jdk-8u261-macosx-x64.dmg（1.8.0_261-b12）</p><p>安装： 双击一路向下即可</p><p>安装目录：/Library/Java/JavaVirtualMachines</p><h2 id="安装-Maven"><a href="#安装-Maven" class="headerlink" title="安装 Maven"></a>安装 Maven</h2><p>官网下载：<a href="https://maven.apache.org/download.cgi" target="_blank" rel="noopener">https://maven.apache.org/download.cgi</a></p><p>版本：3.6.3</p><p>解压（安装）目录：/Users/dongliangqiong/Documents/sangedon/devtools/software</p><ul><li>添加环境变量</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 创建.bash_profile文件</span><br><span class="line">vim ~/.bash_profile</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 导出变量</span><br><span class="line">export MAVEN_HOME=/Users/dongliangqiong/Documents/sangedon/devtools/software/apache-maven-3.6.3</span><br><span class="line">export PATH=$PATH:$MAVEN_HOME/bin</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 使生效</span><br><span class="line">source ~/.bash_profile</span><br></pre></td></tr></table></figure><p>修改本地仓库路径：</p><p>修改文件：/Users/dongliangqiong/Documents/sangedon/devtools/software/apache-maven-3.6.3/conf/settings.xml </p><p>修改内容：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">localRepository</span>&gt;</span>/Users/dongliangqiong/Documents/sangedon/devtools/software/maven-repo<span class="tag">&lt;/<span class="name">localRepository</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="安装Node相关"><a href="#安装Node相关" class="headerlink" title="安装Node相关"></a>安装Node相关</h2><ul><li><p>安装NodeJS</p><p>官网下载：<a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">https://nodejs.org/en/download/</a></p><p>版本： Latest LTS Version: <strong>12.18.3</strong> (includes npm 6.14.6)</p><p>下载文件：node-v12.18.3.pkg</p><p>安装步骤：双击 -&gt; 下一步 即可</p><p>成功截图：</p><p><img src="/paper/Mac-电脑基础开发环境搭建/image-20200808111650459.png" alt="image-20200808111650459"></p></li></ul><ul><li><p>添加 淘宝npm镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config set registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure></li><li><p>安装cnpm 代替 npm使用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure></li><li><p>安装hexo</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo npm install -g hexo</span><br></pre></td></tr></table></figure></li><li><p>安装 yarn</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -o- -L https://yarnpkg.com/install.sh | bash</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;安装git&quot;&gt;&lt;a href=&quot;#安装git&quot; class=&quot;headerlink&quot; title=&quot;安装git&quot;&gt;&lt;/a&gt;安装git&lt;/h2&gt;&lt;p&gt;官网下载： &lt;a href=&quot;https://www.git-scm.com/download/&quot; target=&quot;
      
    
    </summary>
    
      <category term="环境搭建" scheme="http://blog.sangedon.cn/categories/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    
    
      <category term="Mac" scheme="http://blog.sangedon.cn/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>Java实现SSL双向认证</title>
    <link href="http://blog.sangedon.cn/paper/Java%E5%AE%9E%E7%8E%B0SSL%E5%8F%8C%E5%90%91%E8%AE%A4%E8%AF%81/"/>
    <id>http://blog.sangedon.cn/paper/Java实现SSL双向认证/</id>
    <published>2020-04-13T10:51:07.000Z</published>
    <updated>2020-10-13T11:21:59.766Z</updated>
    
    <content type="html"><![CDATA[<blockquote><ul><li>通常客户端连接服务器时会需要校验服务器是否<code>真实、正确</code>，如浏览器输入 <code>https://baidu.com</code>，这种单向确认服务器是否可靠的认证方式为<strong><code>单向认证</code></strong></li><li>实际场景中，我们还经常会需要<strong>同时</strong>验证<strong>服务器</strong>和<strong>客户端</strong>连接的双方是否均为安全、可靠，即服务端为每个用户颁发一个<strong><code>唯一的、不公开</code></strong>的数字证书，客户端通过数字证书来访问服务器，此时，客户端和服务器的交互就是在通信协议上附加SSL协议，确保了 <strong>1.</strong> 服务器和客户端均为安全可靠，互相认可，<strong>2.</strong> 通信内容是加密的，网络嗅探工具无法获取明文数据，这种认证方式即为<strong><code>双向认证</code></strong></li></ul></blockquote><ul><li>下面将通过<strong><code>JSSE</code></strong>（Java Security Socket Extension）来模拟<code>Server</code> 和 <code>Client</code>的双向认证</li></ul><p>注：<code>JSSE</code>是Sun为了解决在Internet上的安全通讯而推出的解决方案。它实现了SSL和TSL（传输层安全）协议。在<code>JSSE</code>中包含了数据加密，服务器验证，消息完整性和客户端验证等技术。通过使用<code>JSSE</code>，开发人员可以在客户端和服务器之间通过TCP/IP协议安全地传输数据。</p><h3 id="证书准备"><a href="#证书准备" class="headerlink" title="证书准备"></a>证书准备</h3><p>为了实现双向认证，Server 和 Client 端均需要如下两个信息文件（具体如下所列），在此使用<code>Java</code>自带的<code>keytool</code>命令生成证书文件</p><ul><li>KeyStore：服务器端（客户端）的私钥</li><li>Trust KeyStore：保存服务器端（客户端）信任的授权证书</li></ul><p><strong>1.</strong> 生成服务器端私钥并导入到服务端KeyStore文件中，命令过程中需要填写一些内容，根据需求设置即可，如下图。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">keytool -genkey -alias serverkey -keystore kserver.keystore</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 需设置内容</span><br><span class="line"><span class="meta">#</span> keystore密码：123456</span><br><span class="line"><span class="meta">#</span> 名字和姓氏：sangedon</span><br><span class="line"><span class="meta">#</span> 组织单位名称：none</span><br><span class="line"><span class="meta">#</span> 组织名称：none</span><br><span class="line"><span class="meta">#</span> 城市或区域名称：BJ</span><br><span class="line"><span class="meta">#</span> 州或省份名称：BJ</span><br><span class="line"><span class="meta">#</span> 国家代码：CN</span><br></pre></td></tr></table></figure><blockquote><p><strong>注：</strong>serverkey私钥的密码，不填写和keystore的密码保持一致。这里千万注意，直接回车就行，不用修改密码。否则在后面的程序中无法直接应用这个私钥，会报错。</p></blockquote><p><img src="/paper/Java实现SSL双向认证/image-20201013185615629.png" alt="生成服务端私钥"></p><ul><li>生成的<code>kserver.keystore</code>是提供给服务端使用，其中保存了服务端的私钥</li></ul><p><strong>2.</strong> 根据私钥，导出服务端证书</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keytool -export -alias serverkey -keystore kserver.keystore -file server.crt</span><br></pre></td></tr></table></figure><p><img src="/paper/Java实现SSL双向认证/image-20201013185805978.png" alt="导出证书"></p><ul><li><code>server.crt</code>就是服务端的证书</li></ul><p><strong>3.</strong> 将服务端证书，导入客户端Trust keyStore中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keytool -import -alias serverkey -file server.crt -keystore tclient.keystore</span><br></pre></td></tr></table></figure><p><img src="/paper/Java实现SSL双向认证/image-20201013185925690.png" alt="客户端受信任证书列表保存服务端证书"></p><ul><li><code>tclient.keystore</code>为客户端保存的受信任的证书</li></ul><blockquote><p>使用上述同样的方法，生成客户端私钥，客户端证书，并导入到服务端受信任证书列表，命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span> keytool -genkey -alias clientkey -keystore kclient.keystore</span><br><span class="line"><span class="meta">&gt;</span> keytool -export -alias clientkey -keystore kclient.keystore -file client.crt</span><br><span class="line"><span class="meta">&gt;</span> keytool -import -alias clientkey -file client.crt -keystore tserver.keystore</span><br><span class="line"><span class="meta">&gt;</span></span><br></pre></td></tr></table></figure></blockquote><ul><li>生成如下证书文件</li></ul><p><img src="/paper/Java实现SSL双向认证/image-20201013190722635.png" alt="生成的证书"></p><h3 id="代码验证"><a href="#代码验证" class="headerlink" title="代码验证"></a>代码验证</h3><ul><li>客户端代码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"><span class="keyword">import</span> java.security.KeyStore;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.net.ssl.KeyManagerFactory;</span><br><span class="line"><span class="keyword">import</span> javax.net.ssl.SSLContext;</span><br><span class="line"><span class="keyword">import</span> javax.net.ssl.SSLSocket;</span><br><span class="line"><span class="keyword">import</span> javax.net.ssl.TrustManagerFactory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * SSL 连接客户端</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String HOST = <span class="string">"127.0.0.1"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PORT = <span class="number">8888</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String CLIENT_KEY_STORE_PASSWORD = <span class="string">"123456"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String CLIENT_TRUST_KEY_STORE_PASSWORD = <span class="string">"123456"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String KS_FILE = <span class="string">"client/kclient.keystore"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TKS_FILE = <span class="string">"client/tclient.keystore"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> SSLSocket sslSocket;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Client client = <span class="keyword">new</span> Client();</span><br><span class="line">        client.init();</span><br><span class="line">        client.process();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 建立连接处理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sslSocket == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"SSL 连接尚未建立"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            InputStream is = sslSocket.getInputStream();</span><br><span class="line">            OutputStream os = sslSocket.getOutputStream();</span><br><span class="line">            BufferedInputStream bi = <span class="keyword">new</span> BufferedInputStream(is);</span><br><span class="line">            BufferedOutputStream bo = <span class="keyword">new</span> BufferedOutputStream(os);</span><br><span class="line">            bo.write(<span class="string">"Client message"</span>.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">            bo.flush();</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            bi.read(bytes);</span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(bytes, StandardCharsets.UTF_8));</span><br><span class="line"></span><br><span class="line">            sslSocket.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建SSL对话上下文，导入客户端秘钥keystore，导入客户端信任的keystore（服务端证书），初始化SSLSocket连接</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            SSLContext sslContext = SSLContext.getInstance(<span class="string">"SSL"</span>);</span><br><span class="line">            KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(<span class="string">"SunX509"</span>);</span><br><span class="line">            TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(<span class="string">"SunX509"</span>);</span><br><span class="line">            KeyStore ks = KeyStore.getInstance(<span class="string">"JKS"</span>);</span><br><span class="line">            KeyStore tks = KeyStore.getInstance(<span class="string">"JKS"</span>);</span><br><span class="line">            ks.load(<span class="keyword">new</span> FileInputStream(KS_FILE), CLIENT_KEY_STORE_PASSWORD.toCharArray());</span><br><span class="line">            tks.load(<span class="keyword">new</span> FileInputStream(TKS_FILE), CLIENT_TRUST_KEY_STORE_PASSWORD.toCharArray());</span><br><span class="line">            keyManagerFactory.init(ks, CLIENT_KEY_STORE_PASSWORD.toCharArray());</span><br><span class="line">            trustManagerFactory.init(tks);</span><br><span class="line">            sslContext.init(keyManagerFactory.getKeyManagers(), trustManagerFactory.getTrustManagers(), <span class="keyword">null</span>);</span><br><span class="line">            sslSocket = (SSLSocket) sslContext.getSocketFactory().createSocket(HOST, PORT);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>服务端代码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"><span class="keyword">import</span> java.security.KeyStore;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.net.ssl.KeyManagerFactory;</span><br><span class="line"><span class="keyword">import</span> javax.net.ssl.SSLContext;</span><br><span class="line"><span class="keyword">import</span> javax.net.ssl.SSLServerSocket;</span><br><span class="line"><span class="keyword">import</span> javax.net.ssl.TrustManagerFactory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * SSL 连接服务端</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PORT = <span class="number">8888</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SERVER_KEY_STORE_PASSWORD = <span class="string">"123456"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SERVER_TRUST_KEY_STORE_PASSWORD = <span class="string">"123456"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String KS_FILE = <span class="string">"server/kserver.keystore"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TKS_FILE = <span class="string">"server/tserver.keystore"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> SSLServerSocket sslServerSocket;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Server server = <span class="keyword">new</span> Server();</span><br><span class="line">        server.init();</span><br><span class="line">        server.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 等待客户端连接，进行通信</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sslServerSocket == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"SSL 连接尚未建立"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Socket socket = sslServerSocket.accept();</span><br><span class="line">            InputStream is = socket.getInputStream();</span><br><span class="line">            OutputStream os = socket.getOutputStream();</span><br><span class="line">            BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(is);</span><br><span class="line">            BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(os);</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            bis.read(bytes);</span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(bytes, StandardCharsets.UTF_8));</span><br><span class="line">            bos.write(<span class="string">"Server accept"</span>.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">            bos.flush();</span><br><span class="line">            socket.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建SSL对话上下文，导入服务端秘钥keystore，导入服务端信任的keystore（客户端证书），初始化SSLServerSocket连接</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            SSLContext sslContext = SSLContext.getInstance(<span class="string">"SSL"</span>);</span><br><span class="line">            KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(<span class="string">"SunX509"</span>);</span><br><span class="line">            TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(<span class="string">"SunX509"</span>);</span><br><span class="line">            KeyStore ks = KeyStore.getInstance(<span class="string">"JKS"</span>);</span><br><span class="line">            KeyStore tks = KeyStore.getInstance(<span class="string">"JKS"</span>);</span><br><span class="line">            ks.load(<span class="keyword">new</span> FileInputStream(KS_FILE), SERVER_KEY_STORE_PASSWORD.toCharArray());</span><br><span class="line">            tks.load(<span class="keyword">new</span> FileInputStream(TKS_FILE), SERVER_TRUST_KEY_STORE_PASSWORD.toCharArray());</span><br><span class="line">            keyManagerFactory.init(ks, SERVER_KEY_STORE_PASSWORD.toCharArray());</span><br><span class="line">            trustManagerFactory.init(tks);</span><br><span class="line">            sslContext.init(keyManagerFactory.getKeyManagers(), trustManagerFactory.getTrustManagers(), <span class="keyword">null</span>);</span><br><span class="line">            sslServerSocket = (SSLServerSocket) sslContext.getServerSocketFactory().createServerSocket(PORT);</span><br><span class="line">            sslServerSocket.setNeedClientAuth(<span class="keyword">true</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>分别启动服务端和客户端即可验证</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;通常客户端连接服务器时会需要校验服务器是否&lt;code&gt;真实、正确&lt;/code&gt;，如浏览器输入 &lt;code&gt;https://baidu.com&lt;/code&gt;，这种单向确认服务器是否可靠的认证方式为&lt;strong&gt;&lt;code&gt;单向认证&lt;/c
      
    
    </summary>
    
      <category term="Java" scheme="http://blog.sangedon.cn/categories/Java/"/>
    
    
      <category term="加密技术" scheme="http://blog.sangedon.cn/tags/%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>Docker中安装Redis</title>
    <link href="http://blog.sangedon.cn/paper/Docker%E4%B8%AD%E5%AE%89%E8%A3%85Redis/"/>
    <id>http://blog.sangedon.cn/paper/Docker中安装Redis/</id>
    <published>2019-09-20T07:51:27.000Z</published>
    <updated>2020-09-23T05:14:55.465Z</updated>
    
    <content type="html"><![CDATA[<h2 id="单机安装"><a href="#单机安装" class="headerlink" title="单机安装"></a>单机安装</h2><ul><li>下载</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull redis</span><br></pre></td></tr></table></figure><ul><li>安装运行</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name redis -p 6379:6379 -v /opt/docker/redis/data:/data -v /opt/docker/redis/conf/redis.conf:/etc/redis/redis.conf -d redis redis-server /etc/redis/redis.conf</span><br></pre></td></tr></table></figure><ul><li>设置配置文件</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 在/opt/docker/redis/conf/目录下生成配置文件即可，后续可补充配置，重启即可</span><br><span class="line">touch redis.conf</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;单机安装&quot;&gt;&lt;a href=&quot;#单机安装&quot; class=&quot;headerlink&quot; title=&quot;单机安装&quot;&gt;&lt;/a&gt;单机安装&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;下载&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr
      
    
    </summary>
    
      <category term="环境搭建" scheme="http://blog.sangedon.cn/categories/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    
    
      <category term="docker" scheme="http://blog.sangedon.cn/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker中安装MySQL</title>
    <link href="http://blog.sangedon.cn/paper/Docker%E4%B8%AD%E5%AE%89%E8%A3%85MySQL/"/>
    <id>http://blog.sangedon.cn/paper/Docker中安装MySQL/</id>
    <published>2019-09-20T07:05:52.000Z</published>
    <updated>2020-09-23T05:14:55.465Z</updated>
    
    <content type="html"><![CDATA[<h2 id="单实例安装"><a href="#单实例安装" class="headerlink" title="单实例安装"></a>单实例安装</h2><ul><li>下载镜像</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull mysql:5.7</span><br></pre></td></tr></table></figure><ul><li>安装</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 3306:3306 --name mysql -v /opt/docker/mysql/log:/var/log/mysql -v /opt/docker/mysql/data:/var/lib/mysql -v /opt/docker/mysql/conf:/etc/mysql -e MYSQL_ROOT_PASSWORD=root -d mysql:5.7</span><br></pre></td></tr></table></figure><p>参数说明：</p><ol><li>-p 3306:3306 将容器的3306端口映射到主机的3306端口</li><li>-v 同步主机目录和容器目录</li><li>-e 初始化mysql的root用户密码</li></ol><ul><li>配置文件设置</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 在/opt/docker/mysql/conf下执行</span><br><span class="line">vi my.cnf</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 文件中将下列配置拷贝进去即可</span><br><span class="line">[client]</span><br><span class="line">default-character-set=utf8</span><br><span class="line"></span><br><span class="line">[mysql]</span><br><span class="line">default-character-set=utf8</span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line">init_connect='SET collation_connection=utf8_unicode_ci'</span><br><span class="line">init_connect='SET NAMES utf8'</span><br><span class="line">character-set-server=utf8</span><br><span class="line">collation-server=utf8_unicode_ci</span><br><span class="line">skip-character-set-client-handshake</span><br><span class="line">skip-name-resolve</span><br></pre></td></tr></table></figure><ul><li>重启</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart mysql</span><br></pre></td></tr></table></figure><blockquote><p>MYSQL 服务启动成功！</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;单实例安装&quot;&gt;&lt;a href=&quot;#单实例安装&quot; class=&quot;headerlink&quot; title=&quot;单实例安装&quot;&gt;&lt;/a&gt;单实例安装&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;下载镜像&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;tab
      
    
    </summary>
    
      <category term="环境搭建" scheme="http://blog.sangedon.cn/categories/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    
    
      <category term="docker" scheme="http://blog.sangedon.cn/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>CentOS 7上Nginx的安装及基本配置</title>
    <link href="http://blog.sangedon.cn/paper/CentOS%207%E4%B8%8Anginx%E5%AE%89%E8%A3%85%E5%8F%8A%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE/"/>
    <id>http://blog.sangedon.cn/paper/CentOS 7上nginx安装及相关配置/</id>
    <published>2019-06-23T01:50:12.000Z</published>
    <updated>2020-09-23T05:14:55.465Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p><em>Nginx</em> (engine x) 是一个高性能的<code>HTTP</code>和<code>反向代理</code>服务，也是一个<code>IMAP/POP3/SMTP</code>服务。由俄罗斯人伊戈尔·赛索耶夫为Rambler.ru站点用<strong>C语言</strong>开发的，第一个公开版本0.1.0发布于2004年10月4日，2011年成立同名公司，以提供支持。其源代码以BSD-like 许可证的形式发布，作为一款轻量级 Web/反向代理 服务器以及电子邮件（IMAP/POP3）代理服务器，其主要特点是每条连接占有内存少，并发能力强，常用于Web服务器、反向代理、负载均衡以及HTTP缓存等场景。</p><h2 id="编译安装-推荐"><a href="#编译安装-推荐" class="headerlink" title="编译安装(推荐)"></a>编译安装(推荐)</h2><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><h4 id="gcc"><a href="#gcc" class="headerlink" title="gcc"></a>gcc</h4><blockquote><p>安装 nginx 需要先将官网下载的源码进行编译，编译依赖 gcc 环境，如果没有 gcc 环境，则需要安装：</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install gcc-c++</span><br></pre></td></tr></table></figure><h4 id="PCRE-pcre-devel"><a href="#PCRE-pcre-devel" class="headerlink" title="PCRE pcre-devel"></a>PCRE pcre-devel</h4><blockquote><p>PCRE(Perl Compatible Regular Expressions) 是一个Perl库，包括 perl 兼容的正则表达式库。nginx 的 http 模块使用 pcre 来解析正则表达式，所以需要在 linux 上安装 pcre 库，pcre-devel 是使用 pcre 开发的一个二次开发库，nginx也需要此库。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y pcre pcre-devel</span><br></pre></td></tr></table></figure><h4 id="zlib"><a href="#zlib" class="headerlink" title="zlib"></a>zlib</h4><blockquote><p>zlib 库提供了很多种压缩和解压缩的方式， nginx 使用 zlib 对 http 包的内容进行 gzip ，所以需要在 CentOS上安装 zlib 库。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y zlib zlib-devel</span><br></pre></td></tr></table></figure><h4 id="OpenSSL"><a href="#OpenSSL" class="headerlink" title="OpenSSL"></a>OpenSSL</h4><blockquote><p>OpenSSL 是一个强大的安全套接字层密码库，囊括主要的密码算法、常用的密钥和证书封装管理功能及 SSL 协议，并提供丰富的应用程序供测试或其它目的使用。<br>nginx 不仅支持 http 协议，还支持 https（即在ssl协议上传输http），所以需要在 CentOS上 安装 OpenSSL 库。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y openssl openssl-devel</span><br></pre></td></tr></table></figure><ul><li>安装环境综合命令</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install gcc gcc-c++ autoconf automake zlib zlib-devel openssl openssl-devel pcre-devel</span><br></pre></td></tr></table></figure><h3 id="Nginx下载及安装"><a href="#Nginx下载及安装" class="headerlink" title="Nginx下载及安装"></a>Nginx下载及安装</h3><ul><li><a href="https://nginx.org/en/download.html" target="_blank" rel="noopener">官方下载地址</a></li><li>命令行下载</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -c https://nginx.org/download/nginx-1.14.1.tar.gz</span><br></pre></td></tr></table></figure><p>成功结果如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[sange@centos-7 java]$ wget -c https://nginx.org/download/nginx-1.14.1.tar.gz</span><br><span class="line">--2019-04-15 22:58:27--  https://nginx.org/download/nginx-1.14.1.tar.gz</span><br><span class="line">Resolving nginx.org (nginx.org)... 95.211.80.227, 62.210.92.35, 2001:1af8:4060:a004:21::e3</span><br><span class="line">Connecting to nginx.org (nginx.org)|95.211.80.227|:443... connected.</span><br><span class="line">HTTP request sent, awaiting response... 200 OK</span><br><span class="line">Length: 1014040 (990K) [application/octet-stream]</span><br><span class="line">Saving to: ‘nginx-1.14.1.tar.gz’</span><br><span class="line"></span><br><span class="line"><span class="meta">100%</span>[======================================&gt;] 1,014,040    210KB/s   in 4.7s   </span><br><span class="line"></span><br><span class="line">2019-04-15 22:58:33 (210 KB/s) - ‘nginx-1.14.1.tar.gz’ saved [1014040/1014040]</span><br></pre></td></tr></table></figure><h3 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf nginx-1.14.1.tar.gz</span><br></pre></td></tr></table></figure><h4 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">drwxr-xr-x. 6 sange sange   4096 Apr 15 23:16 auto   # </span><br><span class="line">-rw-r--r--. 1 sange sange 287441 Nov  6 21:52 CHANGES</span><br><span class="line">-rw-r--r--. 1 sange sange 438114 Nov  6 21:52 CHANGES.ru</span><br><span class="line">drwxr-xr-x. 2 sange sange    168 Apr 15 23:16 conf</span><br><span class="line">-rwxr-xr-x. 1 sange sange   2502 Nov  6 21:52 configure</span><br><span class="line">drwxr-xr-x. 4 sange sange     72 Apr 15 23:16 contrib</span><br><span class="line">drwxr-xr-x. 2 sange sange     40 Apr 15 23:16 html</span><br><span class="line">-rw-r--r--. 1 sange sange   1397 Nov  6 21:52 LICENSE</span><br><span class="line">drwxr-xr-x. 2 sange sange     21 Apr 15 23:16 man</span><br><span class="line">-rw-r--r--. 1 sange sange     49 Nov  6 21:52 README</span><br><span class="line">drwxr-xr-x. 9 sange sange     91 Apr 15 23:16 src</span><br></pre></td></tr></table></figure><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>使用默认配置即可，也可自定义配置</p><ol><li>使用默认配置</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 安装完成后nginx.conf等相关文件及目录即在 /usr/local/nginx 目录下</span><br><span class="line">[sange@centos-7 nginx-1.14.1]$ ./configure --prefix=/usr/local/nginx</span><br></pre></td></tr></table></figure><ol start="2"><li>自定义配置（不推荐）</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">./configure </span><br><span class="line"><span class="meta">#</span> 以下为’./configure‘ 命令的参数，’=‘后为各项参数的默认值</span><br><span class="line">--prefix=/usr/local/nginx  # Nginx安装路径。</span><br><span class="line">--conf-path=/usr/local/nginx/conf/nginx.conf  # 在没有给定-c选项下默认的nginx.conf的路径</span><br><span class="line">--sbin-path=/usr/local/nginx/sbin  # Nginx可执行文件安装路径。</span><br><span class="line">--pid-path=/usr/local/nginx/conf/nginx.pid  # 在nginx.conf中没有指定pid指令的情况下，默认的nginx.pid的路径</span><br><span class="line">--lock-path=/var/lock/nginx.lock  # nginx.lock文件的路径</span><br><span class="line">--error-log-path=/var/log/nginx/error.log  # 在nginx.conf中没有指定error_log指令的情况下，默认的错误日志的路径</span><br><span class="line">--http-log-path=/var/log/nginx/access.log  # 在nginx.conf中没有指定access_log指令的情况下，默认的访问日志的路径</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 其他参数含义，一般默认即可</span><br><span class="line">--with-*  # 表明启用某些功能模块</span><br><span class="line">--without-*  # 表明禁用某些功能模块</span><br></pre></td></tr></table></figure><h3 id="编译及安装"><a href="#编译及安装" class="headerlink" title="编译及安装"></a>编译及安装</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[sange@centos-7 nginx-1.14.1]$ sudo make &amp; make install</span><br></pre></td></tr></table></figure><h3 id="操作命令"><a href="#操作命令" class="headerlink" title="操作命令"></a>操作命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[sange@centos-7 nginx-1.14.1]$ whereis nginx  # 查找安装目录</span><br><span class="line">nginx: /usr/local/nginx</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 进入安装目录下的二进制执行文件目录进行相关操作</span><br><span class="line">[sange@centos-7 nginx-1.14.1]$ cd /usr/local/nginx/sbin/  </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 以下为nginx操作命令</span><br><span class="line">./nginx  # 启动 nginx</span><br><span class="line">./nginx -s stop  # 此方式相当于先查出nginx进程id再使用kill命令强制杀掉进程</span><br><span class="line">./nginx -s quit  # 此方式停止步骤是待nginx进程处理任务完毕进行停止</span><br><span class="line">./nginx -s reload  # 当修改 nginx.conf 后重新加载配置文件令其生效</span><br></pre></td></tr></table></figure><h3 id="开机自启动"><a href="#开机自启动" class="headerlink" title="开机自启动"></a>开机自启动</h3><p>即在<code>rc.local</code>增加启动代码就可以了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/rc.local</span><br></pre></td></tr></table></figure><p>增加一行 <code>/usr/local/nginx/sbin/nginx</code>，具体如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line"><span class="meta">#</span> THIS FILE IS ADDED FOR COMPATIBILITY PURPOSES</span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span> It is highly advisable to create own systemd services or udev rules</span><br><span class="line"><span class="meta">#</span> to run scripts during boot instead of using this file.</span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span> In contrast to previous versions due to parallel execution during boot</span><br><span class="line"><span class="meta">#</span> this script will NOT be run after all other services.</span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span> Please note that you must run 'chmod +x /etc/rc.d/rc.local' to ensure</span><br><span class="line"><span class="meta">#</span> that this script will be executed during boot.</span><br><span class="line"></span><br><span class="line">touch /var/lock/subsys/local</span><br><span class="line">/usr/local/nginx/sbin/nginx  # 增加的一行</span><br></pre></td></tr></table></figure><p>设置<code>rc.local</code>非root用户执行权限：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 755 rc.local</span><br></pre></td></tr></table></figure><h2 id="YUM安装"><a href="#YUM安装" class="headerlink" title="YUM安装"></a>YUM安装</h2><p>在CentOS下，yum源不提供nginx的安装，可以通过切换yum源的方法获取安装yum源，下例为官网的yum源。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo rpm -ivh http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm</span><br></pre></td></tr></table></figure><p>安装命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y nginx</span><br></pre></td></tr></table></figure><p>通过<code>whereis nginx</code>查看nginx默认安装路径</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/etc/nginx/  # Nginx默认配置路径，nginx.conf在此</span><br><span class="line">/var/run/nginx.pid  # PID目录</span><br><span class="line">/var/log/nginx/error.log  # 错误日志</span><br><span class="line">/var/log/nginx/access.log  # 访问日志</span><br><span class="line">/usr/share/nginx/html  # 默认站点目录</span><br></pre></td></tr></table></figure><p>测试命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nginx -t </span><br><span class="line"><span class="meta">#</span> 测试成功结果</span><br><span class="line">nginx: the configuration file /etc/nginx/nginx.conf syntax is ok</span><br><span class="line">nginx: configuration file /etc/nginx/nginx.conf test is successful</span><br></pre></td></tr></table></figure><p>开机自启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl enable nginx</span><br></pre></td></tr></table></figure><p>操作命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start nginx  # 启动服务</span><br><span class="line">sudo systemctl restart nginx  # 停止服务</span><br><span class="line">sudo systemctl reload nginx  # 重新加载配置</span><br></pre></td></tr></table></figure><p>yum卸载nginx命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum remove -y nginx</span><br></pre></td></tr></table></figure><h2 id="防火墙问题"><a href="#防火墙问题" class="headerlink" title="防火墙问题"></a>防火墙问题</h2><blockquote><p>因CentOS 7 防火墙未开放80端口导致本机不能成功访问虚拟机问题</p></blockquote><h3 id="CentOS-7-防火墙相关命令"><a href="#CentOS-7-防火墙相关命令" class="headerlink" title="CentOS 7 防火墙相关命令"></a>CentOS 7 防火墙相关命令</h3><p>查看已开放端口</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo firewall-cmd --list-ports</span><br></pre></td></tr></table></figure><p>开放<code>80</code>端口</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> ContOS 7 防火墙命令改为 `firewall`, 而7以下的防火墙命令为 `iptables`(且具体命令也不同)</span><br><span class="line">sudo firewall-cmd --zone=public --add-port=80/tcp --permanent</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 其他指令含义：</span><br><span class="line">–zone  #作用域</span><br><span class="line">–add-port=80/tcp  #添加端口，格式为：端口/通讯协议</span><br><span class="line">–permanent  #永久生效，没有此参数重启后失效</span><br></pre></td></tr></table></figure><p>设置完成之后需<strong>重启</strong>防火墙</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo firewall-cmd --reload  #重启firewall</span><br><span class="line">sudo systemctl stop firewalld.service  #停止firewall</span><br><span class="line">sudo systemctl disable firewalld.service  #禁止firewall开机启动</span><br></pre></td></tr></table></figure><h3 id="CentOS-7以下防火墙相关命令"><a href="#CentOS-7以下防火墙相关命令" class="headerlink" title="CentOS 7以下防火墙相关命令"></a>CentOS 7以下防火墙相关命令</h3><p>开放80端口</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo /sbin/iptables -I INPUT -p tcp --dport 80 -j ACCEPT</span><br></pre></td></tr></table></figure><p>保存</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo /etc/rc.d/init.d/iptables save</span><br></pre></td></tr></table></figure><p>查看开放的端口</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo /etc/init.d/iptables status</span><br></pre></td></tr></table></figure><p>开启与关闭防火墙</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 永久性生效，重启后不会复原</span><br><span class="line">sudo chkconfig iptables on  # 开启</span><br><span class="line">sudo chkconfig iptables off  # 关闭</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 即时生效，重启后复原</span><br><span class="line">sudo service iptables start  # 开启</span><br><span class="line">sudo service iptables stop  # 关闭</span><br></pre></td></tr></table></figure><ul><li><p>参考文章</p><p><a href="https://www.linuxidc.com/Linux/2016-09/134907.htm" target="_blank" rel="noopener">mafly</a></p><p><a href="https://blog.csdn.net/jack85986370/article/details/51169203" target="_blank" rel="noopener">Deep_Deep_Learning</a></p><p><a href="https://segmentfault.com/a/1190000014750417" target="_blank" rel="noopener">金武飞扬</a></p><p><a href="https://segmentfault.com/a/1190000018791822" target="_blank" rel="noopener">Guoye</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;&lt;em&gt;Nginx&lt;/em&gt; (engine x) 是一个高性能的&lt;code&gt;HTTP&lt;/code&gt;和&lt;code&gt;反向代理&lt;/code&gt;服务，也是一个&lt;code&gt;IMAP/POP3/SMTP&lt;/code&gt;服务。由俄罗斯人伊戈尔·赛索耶夫为
      
    
    </summary>
    
      <category term="中间件" scheme="http://blog.sangedon.cn/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
      <category term="服务器" scheme="http://blog.sangedon.cn/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
      <category term="学习笔记" scheme="http://blog.sangedon.cn/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>博文列表</title>
    <link href="http://blog.sangedon.cn/paper/%E6%94%B6%E8%97%8F%E5%88%97%E8%A1%A8/"/>
    <id>http://blog.sangedon.cn/paper/收藏列表/</id>
    <published>2019-06-13T08:25:18.000Z</published>
    <updated>2020-10-10T04:25:51.020Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><ul><li><a href="https://segmentfault.com/a/1190000015815061" target="_blank" rel="noopener">MySQL/InnoDB中，乐观锁、悲观锁、共享锁、排它锁、行锁、表锁、死锁概念的理解</a></li><li><a href="https://segmentfault.com/a/1190000008491597" target="_blank" rel="noopener">详细深入分析Java ClassLoader 工作机制</a></li><li><a href="https://segmentfault.com/a/1190000016085105" target="_blank" rel="noopener">Java内存模型</a></li><li><a href="https://juejin.im/post/5c6b9c09f265da2d8a55a855" target="_blank" rel="noopener">MySQL优化面试</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000015815061&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MySQL/InnoDB中，乐观锁、悲观锁、共享锁、排它
      
    
    </summary>
    
      <category term="收藏" scheme="http://blog.sangedon.cn/categories/%E6%94%B6%E8%97%8F/"/>
    
    
      <category term="学习笔记" scheme="http://blog.sangedon.cn/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>2019学习生活规划</title>
    <link href="http://blog.sangedon.cn/paper/2019%E5%AD%A6%E4%B9%A0%E7%94%9F%E6%B4%BB%E8%A7%84%E5%88%92/"/>
    <id>http://blog.sangedon.cn/paper/2019学习生活规划/</id>
    <published>2019-05-25T13:03:22.000Z</published>
    <updated>2020-09-23T05:14:55.464Z</updated>
    
    <content type="html"><![CDATA[<p>知之真切笃实处，即是行；行之明觉精察处，即是知，知行工夫本不可离。                — 知行录</p><a id="more"></a><h2 id="读书计划"><a href="#读书计划" class="headerlink" title="读书计划"></a>读书计划</h2><p>⭐️ 骗钱的    ⭐️⭐️ 内容一般，表达一般     ⭐️⭐️⭐️ 内容尚可，表达一般              一次就够</p><p>⭐️⭐️⭐️⭐️内容丰富，表达较好     ⭐️⭐️⭐️⭐️⭐️ 内容经典，表达较好                值得再看</p><ul><li style="list-style: none"><input type="checkbox" checked> HeadFirst 设计模式    ⭐️⭐️⭐️⭐️     <code>3.12</code>  </li><li style="list-style: none"><input type="checkbox" checked> Java 开发手册 ⭐️⭐️⭐️   <code>2.26</code></li><li style="list-style: none"><input type="checkbox" checked> 码处高效  ⭐️⭐️⭐️   <code>3.2</code></li><li style="list-style: none"><input type="checkbox" checked> 鸟哥的Linux私房菜  ⭐️⭐️⭐️    <code>前七章：3.19</code></li><li style="list-style: none"><input type="checkbox" checked> SQL必知必会   ⭐️⭐️⭐️  <code>3.5</code></li><li style="list-style: none"><input type="checkbox" checked> 高性能MySQL   ⭐️⭐️⭐️⭐️  <code>前六章：3.26</code></li><li style="list-style: none"><input type="checkbox" checked> 剑指Offer   ⭐️⭐️⭐️    <code>5.11</code></li><li style="list-style: none"><input type="checkbox" checked> Thinking In Java  ⭐️⭐️⭐️⭐️</li><li style="list-style: none"><input type="checkbox" checked> 程序源代码面试指南   ⭐️⭐️⭐️⭐️   <code>7.29</code></li><li style="list-style: none"><input type="checkbox" checked> 数据结构与算法分析   ⭐️⭐️⭐️  <code>2.18</code></li><li style="list-style: none"><input type="checkbox" checked> 深入理解JVM  ⭐️⭐️⭐️⭐️⭐️  <code>5.7</code></li><li style="list-style: none"><input type="checkbox" checked> Java并发编程之美  ⭐️⭐️⭐️⭐️  <code>7.07</code></li><li style="list-style: none"><input type="checkbox" checked> Java并发编程的艺术  ⭐️⭐️  <code>6.25</code></li><li style="list-style: none"><input type="checkbox" checked> JavaScript高级程序设计   ⭐️⭐️⭐️⭐️    <code>5.17</code></li><li style="list-style: none"><input type="checkbox" checked> 深入分析 Java Web 技术内幕   ⭐️⭐️    <code>7.12</code></li><li style="list-style: none"><input type="checkbox" checked> 大型网站技术架构—核心原理与案例分析  ⭐️⭐️⭐️⭐️  <code>7.03</code></li><li style="list-style: none"><input type="checkbox" checked> 网络是怎样跑起来的  ⭐️⭐️⭐️⭐️    <code>7.17</code></li><li style="list-style: none"><input type="checkbox" checked> 大话设计模式   ⭐️⭐️⭐️⭐️    <code>7.23</code></li><li style="list-style: none"><input type="checkbox" checked> spring 揭秘   ⭐️⭐️⭐️⭐️    <code>前8章 7.26</code></li><li style="list-style: none"><input type="checkbox" checked> Python 3 网络爬虫开发实战   ⭐️⭐️⭐️    <code>前6章 7.19</code>   </li><li style="list-style: none"><input type="checkbox"> 程序是怎样跑起来的</li><li style="list-style: none"><input type="checkbox"> Redis开发与运维</li><li style="list-style: none"><input type="checkbox"> Redis设计与实现</li><li style="list-style: none"><input type="checkbox"> netty实战</li><li style="list-style: none"><input type="checkbox"> Linux命令行与shell脚本编程大全</li><li style="list-style: none"><input type="checkbox"> 知行录</li></ul><h2 id="技术学习"><a href="#技术学习" class="headerlink" title="技术学习"></a>技术学习</h2><ul><li style="list-style: none"><input type="checkbox" checked> 深入学习理解Java基础知识，如动态代理，注解，反射等，提高面向对象编程的认识</li><li style="list-style: none"><input type="checkbox" checked> 理解Spring基本原理，MVC 框架以及Mybatis的基本实现思路</li><li style="list-style: none"><input type="checkbox" checked> 学习SpringBoot，了解其无配置的原理，理解 restful 风格编程</li><li style="list-style: none"><input type="checkbox"> 深入学习MySQL</li><li style="list-style: none"><input type="checkbox"> 学习 Redis</li><li style="list-style: none"><input type="checkbox"> 学习NIO以及netty框架</li><li style="list-style: none"><input type="checkbox"> 学习Nginx</li><li style="list-style: none"><input type="checkbox"> 学习Docker</li><li style="list-style: none"><input type="checkbox"> 学习 dubbo，了解RPC框架</li><li style="list-style: none"><input type="checkbox"> 了解服务器，如Tomcat，Jetty</li><li style="list-style: none"><input type="checkbox"> 了解Spring Cloud及分布式架构基础知识</li><li style="list-style: none"><input type="checkbox"> 继续学习Python</li></ul><h2 id="习惯培养"><a href="#习惯培养" class="headerlink" title="习惯培养"></a>习惯培养</h2><ul><li style="list-style: none"><input type="checkbox"> 每周六爬山</li><li style="list-style: none"><input type="checkbox"> 早睡</li><li style="list-style: none"><input type="checkbox"> 控制饮食口味，少辣</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;知之真切笃实处，即是行；行之明觉精察处，即是知，知行工夫本不可离。                — 知行录&lt;/p&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://blog.sangedon.cn/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="规划" scheme="http://blog.sangedon.cn/tags/%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>分布式锁的概念及实现</title>
    <link href="http://blog.sangedon.cn/paper/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%AE%9E%E7%8E%B0/"/>
    <id>http://blog.sangedon.cn/paper/分布式锁的概念及实现/</id>
    <published>2019-05-20T08:45:09.000Z</published>
    <updated>2020-09-23T05:14:55.472Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p>对于运行在同一个JVM中的单进程程序而言，要实现线程同步操作可使用语言和类库提供的锁，而对于如今分布在不同服务器上运行的程序而言，要实现线程同步操作，语言和类库提供的锁已不能满足需求，因此，对于此类场景，则可使用分布式锁。分布式锁的实现有多种形式，常见的主要有三种实现方式，如：基于数据库乐观锁；基于 redis 的 set 操作；基于 zookeeper 临时有序节点的特性</p><h2 id="基于数据库实现"><a href="#基于数据库实现" class="headerlink" title="基于数据库实现"></a>基于数据库实现</h2><h3 id="基于数据库表"><a href="#基于数据库表" class="headerlink" title="基于数据库表"></a>基于数据库表</h3><blockquote><p>基于数据库的实现方式的核心思想是：在数据库中创建一个表，表中包含<strong>方法名（资源）</strong>等字段，并在<strong>方法名字段上创建唯一索引</strong>，想要执行某个方法，就使用这个方法名向表中插入数据，成功插入则获取锁，执行完成后删除对应的行数据释放锁。</p></blockquote><ul><li>创建被锁定方法或资源表</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`methodLock`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'主键'</span>,</span><br><span class="line">  <span class="string">`method_name`</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span> <span class="keyword">COMMENT</span> <span class="string">'锁定的方法名'</span>,</span><br><span class="line">  <span class="string">`desc`</span> <span class="built_in">varchar</span>(<span class="number">1024</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'备注信息'</span>,</span><br><span class="line">  <span class="string">`update_time`</span> <span class="built_in">timestamp</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">COMMENT</span> <span class="string">'保存数据时间，自动生成'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> <span class="string">`uidx_method_name`</span> (<span class="string">`method_name `</span>) <span class="keyword">USING</span> BTREE) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 <span class="keyword">COMMENT</span>=<span class="string">'锁定中的方法'</span>;</span><br></pre></td></tr></table></figure><ul><li>获取锁，锁定资源(方法或资源)</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> methodLock(method_name,<span class="keyword">desc</span>) <span class="keyword">values</span> (‘method_name’,‘<span class="keyword">desc</span>’)</span><br></pre></td></tr></table></figure><p>当要获取资源或执行某个方法时，向表中插入该方法记录，由于方法名为唯一索引，所以插入成功则表明已成功获取锁，否则失败</p><ul><li>释放锁</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> methodLock <span class="keyword">where</span> method_name =<span class="string">'method_name'</span></span><br></pre></td></tr></table></figure><p>当方法执行完毕时，删除插入的记录即可释放锁，其他进程中的线程即可通过插入记录获取锁</p><h3 id="基于数据库排他锁"><a href="#基于数据库排他锁" class="headerlink" title="基于数据库排他锁"></a>基于数据库排他锁</h3><blockquote><p>除了可以通过增删操作数据表中的记录以外，其实还可以借助数据中自带的锁来实现分布式锁。我们还用刚刚创建的那张数据库表，通过数据库的排他锁来实现分布式锁。主要 基于MySql的InnoDB引擎，当进行<code>for update</code>操作时，数据库会在查询过程中为当前查询添加排它锁</p></blockquote><ul><li>获取锁(加锁)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lock</span><span class="params">()</span></span>&#123;</span><br><span class="line">    connection.setAutoCommit(<span class="keyword">false</span>)</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">          <span class="comment">// 在查询语句后面增加`for update`，数据库会在查询过程中给数据库表增加排他锁</span></span><br><span class="line">            result = select * from methodLock where method_name=xxx <span class="keyword">for</span> update;</span><br><span class="line">            <span class="keyword">if</span>(result==<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是：InnoDB引擎在加锁的时候，只有通过索引进行检索的时候才会使用行级锁，否则会使用表级锁。如果我们需要使用行级锁，就要为method_name添加索引，并且一定要创建成唯一索引，否则会出现多个重载方法之间无法同时被访问的问题。重载方法的话建议把参数类型也加上。当某条记录被加上排他锁之后，其他线程无法再在该行记录上增加排他锁。</p><p>我们可以认为获得排它锁的线程即获得了分布式锁，当获取到锁之后，就可以执行方法的业务逻辑，执行完方法之后，再通过提交事物方法解锁：</p><ul><li>释放锁</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>&#123;</span><br><span class="line">    connection.commit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法可以有效的解决上面提到的无法释放锁和阻塞锁的问题。</p><ul><li><code>for update</code>语句会在执行成功后立即返回，在执行失败时一直处于阻塞状态，直到成功。</li><li>使用排它锁的方式，服务宕机之后数据库会自己把锁释放掉。</li></ul><h3 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h3><ol><li>无法直接解决数据库单点和可重入问题。</li><li>我们知道，Mysql执行查询语句之前会进行查询优化，因此，尽管我们对<code>method_name</code>使用了唯一索引，且使用<code>for update</code>来显示使用行级锁，但是查询时是否使用索引具体还要根据Mysql根据内部优化策略判断，如果数据量较小的时候，Mysql可能会认为全表扫描效率更高，则不会使用索引而导致InnoDB使用表锁，此时将导致需要获取其他锁的线程阻塞</li><li>如果某个事物长时间占用排它锁，导致长时间占用数据库连接，若类似的耗时连接较多，则数据库连接池将支持不住</li></ol><h3 id="可优化"><a href="#可优化" class="headerlink" title="可优化"></a>可优化</h3><ol><li>因为是基于数据库实现的，数据库的可用性和性能将直接影响分布式锁的可用性及性能，所以，数据库需要双机部署、数据同步、主从切换；</li><li>不具备可重入的特性，因为同一个线程在释放锁之前，行数据一直存在，无法再次成功插入数据，所以，需要在表中新增一列，用于记录当前获取到锁的机器和线程信息，在再次获取锁的时候，先查询表中机器和线程信息是否和当前机器和线程相同，若相同则直接获取锁；</li><li>没有锁失效机制，因为有可能出现成功插入数据后，服务器宕机了，对应的数据没有被删除，当服务恢复后一直获取不到锁，所以，需要在表中新增一列，用于记录失效时间，并且需要有定时任务清除这些失效的数据；</li><li>不具备阻塞锁特性，获取不到锁直接返回失败，所以需要优化获取逻辑，循环多次去获取。</li><li>在实施的过程中会遇到各种不同的问题，为了解决这些问题，实现方式将会越来越复杂；依赖数据库需要一定的资源开销，性能问题需要考虑。</li></ol><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><blockquote><p>基于数据库实现的两种方式都是依赖数据库的一张表，一种是通过表中的记录是否存在判断是否持有分布式锁，另一种是通过数据库的排他锁来实现分布式锁。</p><p><strong>优点</strong></p><p>直接借助数据库，容易理解。</p><p><strong>缺点</strong></p><p>有各种各样的问题，在解决问题的过程中会使整个方案变得越来越复杂。</p><p>操作数据库需要一定的开销，性能问题需要考虑。</p><p>使用数据库的行级锁并不一定靠谱，尤其是当我们的锁表并不大的时候。</p></blockquote><h2 id="基于Redis实现"><a href="#基于Redis实现" class="headerlink" title="基于Redis实现"></a>基于Redis实现</h2><blockquote><p>利用Redis的<strong>set命令</strong>。此命令是原子性操作，只有在key不存在的情况下，才能成功。</p></blockquote><ul><li>加锁</li></ul><p>最简单的方法是使用<strong>set</strong>命令。例如想要给一种商品的秒杀活动加锁，key 为 “lock_sale_商品ID” ，value 假设为 11，若 ret 为 1，则表示加锁成功，为 0 则表示已存在 key，加锁失败</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加锁伪代码</span></span><br><span class="line"><span class="keyword">int</span> ret = set（key，<span class="number">1</span>）;</span><br></pre></td></tr></table></figure><ul><li>解锁</li></ul><p>当获取锁的线程执行完毕，需要释放锁，通过 <code>del</code>操作删除记录，当所释放之后，其他线程即可通过 <code>set</code>操作获取锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 释放锁伪代码</span></span><br><span class="line">del(key)</span><br></pre></td></tr></table></figure><ul><li>锁超时</li></ul><p>当某个获取所得线程在释放锁之前挂掉，该锁将会长期被占用导致共享资源无法为其他线程提供服务，因此需要为锁添加超时时间，以保证在锁在超时占用时也能被正常释放，Redis 2.6.12 之前 set 操作无法设置超时时间，因此 加锁和设置超时时间的操作为非原子性操作，这会导致在极端情况下，某线程获取锁之后，设置超时时间之前挂掉的话，将无法释放锁。好在后面的版本中 set 操作可设置超时时间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加锁，设置超时时间 30s</span></span><br><span class="line"><span class="keyword">int</span> ret = set（key，<span class="number">1</span>，<span class="number">30</span>，NX）</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全过程伪代码如下</span></span><br><span class="line"><span class="keyword">if</span>（setnx（key，<span class="number">1</span>， <span class="number">30</span>， NX） == <span class="number">1</span>）&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">do</span> something ......</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        del（key）</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 以上代码还有一个问题，即若线程A超时时长内方法未执行完毕，其他线程（线程B）在此期间也获取到了锁，则A执行完毕后删除锁，而此时的锁为B的锁，为避免这种情况，在删除锁之前需要判断是否是自己添加的锁，则value可设置为当前线程ID</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 伪代码如下</span></span><br><span class="line"><span class="comment">// 加锁</span></span><br><span class="line">String threadId = Thread.currentThread().getId()</span><br><span class="line">set（key，threadId ，<span class="number">30</span>，NX）</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解锁</span></span><br><span class="line"><span class="keyword">if</span>（threadId .equals(redisClient.get(key))）&#123;</span><br><span class="line">    del(key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解锁操作中判断操作和解锁操作为非原子性操作，此时可通过lua代码来实现这一段代码</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String luaScript = <span class="string">"if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end"</span>;</span><br><span class="line"></span><br><span class="line">redisClient.eval(luaScript , Collections.singletonList(key), Collections.singletonList(threadId));</span><br></pre></td></tr></table></figure><p>此时已经解决了大部分问题，但是多个线程同步操作共享资源时，由于过期时间到达而方法未执行完毕，其他线程还是可以获取同步锁，可通过在获取同步锁的同时开启一个守护线程，例如 过期时间30s 则在29s时，将超时时间延长 一定的时间已达到续航的目的，但是需要注意的是，在方法执行完毕时，一定要手动关闭守护线程</p><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><blockquote><p>使用缓存来代替数据库来实现分布式锁，可以提供更好的性能，同时，很多缓存服务都是集群部署的，可以避免单点问题。并且很多缓存服务都提供了可以用来实现分布式锁的方法，比如redis的setnx方法等。并且，这些缓存服务也都提供了对数据的过期自动删除的支持，可以直接设置超时时间来控制锁的释放。</p><p><strong>优点</strong></p><p>性能好，实现起来较为方便。</p><p><strong>缺点</strong></p><p>通过超时时间来控制锁的失效时间并不是十分的靠谱。</p></blockquote><h2 id="基于zookeeper实现"><a href="#基于zookeeper实现" class="headerlink" title="基于zookeeper实现"></a>基于zookeeper实现</h2><blockquote><p>每个客户端对某个方法加锁时，在zookeeper上的与该方法对应的指定节点的目录下，生成一个临时有序节点。 判断是否获取锁的方式很简单，只需要判断有序节点中序号最小的一个。 当释放锁的时候，只需将这个临时节点删除即可。</p></blockquote><p>Zookeeper的数据结构就像一棵树，由节点（Znode）组成，节点分为四类，利用Zookeeper实现分布式锁主要使用其临时顺序节点的特性完成，节点分类及特性如下：</p><ul><li>持久节点</li></ul><p>默认的节点类型。创建节点的客户端与zookeeper断开连接后，该节点依旧存在 。</p><ul><li>持久顺序节点</li></ul><p>所谓顺序节点，就是在创建节点时，Zookeeper根据创建的时间顺序给该节点名称进行编号。</p><ul><li>临时节点</li></ul><p>和持久节点相反，当创建节点的客户端与zookeeper断开连接后，临时节点会被删除</p><ul><li>临时顺序节点</li></ul><p>临时顺序节点结合和临时节点和顺序节点的特点：在创建节点时，Zookeeper根据创建的时间顺序给该节点名称进行编号；当创建节点的客户端与zookeeper断开连接后，临时节点会被删除。</p><h3 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h3><ul><li>获取锁</li></ul><ol><li>在Zookeeper当中创建一个持久节点ParentLock。当第一个客户端想要获得锁时，需要在ParentLock这个节点下面创建一个<strong>临时顺序节点</strong> Lock1。</li><li>Client1查找ParentLock下面所有的临时顺序节点并排序，判断自己所创建的节点Lock1是不是顺序最靠前的一个。如果是第一个节点，则成功获得锁。</li><li>如果再有一个客户端 Client2 前来获取锁，则在ParentLock下载再创建一个临时顺序节点Lock2。</li><li>Client2查找ParentLock下面所有的临时顺序节点并排序，判断自己所创建的节点Lock2是不是顺序最靠前的一个，结果发现节点Lock2并不是最小的。</li><li>Client2向排序仅比它靠前的节点Lock1注册<strong>Watcher</strong>，用于监听Lock1节点是否存在。这意味着Client2抢锁失败，进入了等待状态。</li><li>如果又有一个客户端Client3前来获取锁，则在ParentLock下载再创建一个临时顺序节点Lock3。</li><li>Client3查找ParentLock下面所有的临时顺序节点并排序，判断自己所创建的节点Lock3是不是顺序最靠前的一个，结果同样发现节点Lock3并不是最小的。于是，Client3向排序仅比它靠前的节点<strong>Lock2</strong>注册Watcher，用于监听Lock2节点是否存在。这意味着Client3同样抢锁失败，进入了等待状态。</li><li>这样一来，Client1得到了锁，Client2监听了Lock1，Client3监听了Lock2。这恰恰形成了一个等待队列，很像是Java当中ReentrantLock所依赖的<strong>AQS</strong>（AbstractQueuedSynchronizer）。</li></ol><ul><li>释放锁</li></ul><p>释放锁分为两种情况：</p><ul><li><ul><li>任务完成，客户端显示释放</li></ul></li></ul><p>当任务完成时，Client1会显示调用删除节点Lock1的指令。</p><ul><li><ul><li>任务执行过程中，客户端崩溃</li></ul><p>获得锁的Client1在任务执行过程中，如果程序崩溃，则会断开与Zookeeper服务端的链接。根据临时节点的特性，相关联的节点Lock1会随之自动删除。</p></li></ul><p>由于Client2一直监听着Lock1的存在状态，当Lock1节点被删除，Client2会立刻收到通知。这时候Client2会再次查询ParentLock下面的所有节点，确认自己创建的节点Lock2是不是目前最小的节点。如果是最小，则Client2顺理成章获得了锁。</p><p>同理，如果Client2也因为任务完成或者节点崩溃而删除了节点Lock2，那么Client3就会接到通知。最终，Client3成功得到了锁。</p><h3 id="Zookeeper可解决问题"><a href="#Zookeeper可解决问题" class="headerlink" title="Zookeeper可解决问题"></a>Zookeeper可解决问题</h3><ul><li>使用Zookeeper可以有效的解决锁无法释放的问题，因为在创建锁的时候，客户端会在ZK中创建一个临时节点，一旦客户端获取到锁之后突然挂掉（Session连接断开），那么这个临时节点就会自动删除掉。其他客户端就可以再次获得锁。</li><li>使用Zookeeper可以实现阻塞的锁，客户端可以通过在ZK中创建顺序节点，并且在节点上绑定监听器，一旦节点有变化，Zookeeper会通知客户端，客户端可以检查自己创建的节点是不是当前所有节点中序号最小的，如果是，那么自己就获取到锁，便可以执行业务逻辑了。</li><li>使用Zookeeper也可以有效的解决不可重入的问题，客户端在创建节点的时候，把当前客户端的主机信息和线程信息直接写入到节点中，下次想要获取锁的时候和当前最小的节点中的数据比对一下就可以了。如果和自己的信息一样，那么自己直接获取到锁，如果不一样就再创建一个临时的顺序节点，参与排队。</li><li>使用Zookeeper可以有效的解决单点问题，ZK是集群部署的，只要集群中有半数以上的机器存活，就可以对外提供服务。</li></ul><h3 id="使用Zookeeper存在的问题"><a href="#使用Zookeeper存在的问题" class="headerlink" title="使用Zookeeper存在的问题"></a>使用Zookeeper存在的问题</h3><p>使用ZK实现的分布式锁好像完全符合了本文开头我们对一个分布式锁的所有期望。但是，其实并不是，Zookeeper实现的分布式锁其实存在一个缺点，那就是性能上可能并没有缓存服务那么高。因为每次在创建锁和释放锁的过程中，都要动态创建、销毁瞬时节点来实现锁功能。ZK中创建和删除节点只能通过Leader服务器来执行，然后将数据同步到所有的Follower机器上。</p><p>其实，使用Zookeeper也有可能带来并发问题，只是并不常见而已。考虑这样的情况，由于网络抖动，客户端可ZK集群的session连接断了，那么zk以为客户端挂了，就会删除临时节点，这时候其他客户端就可以获取到分布式锁了。就可能产生并发问题。这个问题不常见是因为zk有重试机制，一旦zk集群检测不到客户端的心跳，就会重试，Curator客户端支持多种重试策略。多次重试之后还不行的话才会删除临时节点。（所以，选择一个合适的重试策略也比较重要，要在锁的粒度和并发之间找一个平衡。）</p><h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><blockquote><p><strong>优点</strong></p><p>有效的解决单点问题，不可重入问题，非阻塞问题以及锁无法释放的问题。实现起来较为简单。</p><p><strong>缺点</strong></p><p>性能上不如使用缓存实现分布式锁。 需要对ZK的原理有所了解。</p></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>上面三种方式，均无法在复杂性、可靠性、性能等方面无法同时满足，所以，我们需要根据不同的应用场景选择适合的实现方式。</p><ul><li>数据库实现容易理解，且易于实现，但是性能和可靠性方面较差</li><li>Zookeeper实现方式最难理解和实现，但是可靠性好</li><li>Redis实现方式性能较好，可靠性稍差与zookeeper</li></ul><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://mp.weixin.qq.com/s/8fdBKAyHZrfHmSajXT_dnA" target="_blank" rel="noopener">程序员小灰</a></p><p><a href="https://mp.weixin.qq.com/s/xcd8NWYMzpVJ3UKlGPIt9g" target="_blank" rel="noopener">Java后端技术</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;对于运行在同一个JVM中的单进程程序而言，要实现线程同步操作可使用语言和类库提供的锁，而对于如今分布在不同服务器上运行的程序而言，要实现线程同步操作，语言和类库提供的锁已不能满足需求，因此，对于此类场景，则可使用分布式锁。分布式锁的实现有
      
    
    </summary>
    
      <category term="Java" scheme="http://blog.sangedon.cn/categories/Java/"/>
    
    
      <category term="学习笔记" scheme="http://blog.sangedon.cn/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="分布式" scheme="http://blog.sangedon.cn/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>滑动窗口问题</title>
    <link href="http://blog.sangedon.cn/paper/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E9%97%AE%E9%A2%98/"/>
    <id>http://blog.sangedon.cn/paper/滑动窗口问题/</id>
    <published>2019-05-20T07:16:23.000Z</published>
    <updated>2020-09-23T05:14:55.473Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p>滑动窗口是数组/字符串问题中常用的抽象概念。 窗口通常是在数组/字符串中由开始和结束索引定义的一系列元素的集合，即 [i, j)（左闭，右开）。而滑动窗口是可以将两个边界向某一方向“滑动”的窗口。例如，我们将 [i, j) 向右滑动 1 个元素，则它将变为 [i+1, j+1)（左闭，右开）。</p><blockquote><h4 id="问题：给定一个字符串，请你找出其中不含有重复字符的-最长子串-的长度。"><a href="#问题：给定一个字符串，请你找出其中不含有重复字符的-最长子串-的长度。" class="headerlink" title="问题：给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。"></a><strong>问题</strong>：给定一个字符串，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</h4></blockquote><ul><li><p>暴力法</p></li><li><ul><li>比较暴力的方法，嵌套两次循环，时间复杂度为<strong>O(n^2</strong>)，具体思路为：使用一个双端队列，保存遍历到当前字符时不重复的字符串，下一个字符如果存在于队列中，则遍历到下一个字符时的子串长度为两个重复字符之间的距离，否则为上一个不重复子串长度加1</li></ul><p><strong>本方法适用于记录每一个不重复子串的求解，不适用于仅需要最长子串长度的求解</strong></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        LinkedList&lt;Character&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(s.charAt(<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &lt; s.length())&#123;</span><br><span class="line">            <span class="keyword">char</span> temp = s.charAt(index);</span><br><span class="line">            <span class="keyword">int</span> s1 = isInQueue(queue, temp);</span><br><span class="line">            <span class="keyword">if</span> (s1 &gt;= max)&#123;</span><br><span class="line">                max = s1;</span><br><span class="line">            &#125;</span><br><span class="line">            index ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回队列中与目标字符相同字符的距离，即遍历到当前字符时最长不重复长度</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">isInQueue</span><span class="params">(LinkedList&lt;Character&gt; queue, <span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">        LinkedList&lt;Character&gt; queueT = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">if</span> (queue.peekLast()!=c)&#123;</span><br><span class="line">                queueT.offer(queue.pollLast());</span><br><span class="line">                flag ++;</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">                    queue.poll();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!queueT.isEmpty())&#123;</span><br><span class="line">            queue.offer(queueT.pollLast());</span><br><span class="line">        &#125;</span><br><span class="line">        queue.offer(c);</span><br><span class="line">        <span class="keyword">return</span> flag + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用hash表记录不重复子串的字符，可分别使用<code>Set</code>和<code>Map or char[256]</code>字符数组</li><li><ul><li>使用<code>Set</code>， 时间复杂度为<strong>O(2n) —&gt; O(n)</strong>，通过使用 <strong>hash</strong>表作为滑动窗口，检查当前字符是否在不重复子串中仅需<strong>O(1)</strong>的时间，当前使用 <code>HashSet</code> 将字符存储在当前窗口<code>[i, j)</code>）中。 然后向右侧滑动索引 <code>j</code>，如果它不在 <code>HashSet</code> 中，我们会继续滑动<code>j</code>。直到<code>s[j]</code>已经存在于 <code>HashSet</code> 中。此时，找到的没有重复字符的最长子字符串将会以索引 <code>i</code>开头。当对所有的 <code>i</code> 这样做，就可以得到答案。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= j &amp;&amp; j &lt; s.length())&#123;</span><br><span class="line">            <span class="keyword">if</span> (!set.contains(s.charAt(j)))&#123;</span><br><span class="line">                set.add(s.charAt(j++));</span><br><span class="line">                max = Math.max(max, j - i);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                set.remove(s.charAt(i ++));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><ul><li>使用<code>HashMap</code>，时间复杂度为<code>O(n)</code>定义字符到索引的映射，而不是使用集合来判断一个字符是否存在。 当找到重复的字符时，可以立即跳过该窗口，也就是说，如果 <code>s[j]</code>在 <code>[i, j)</code>有与<code>j&#39;</code>的字符，我们不需要逐渐增加<code>i</code>以直接跳过<code>[i，j&#39;]</code>，并将<code>j&#39; + 1</code>。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length(), ans = <span class="number">0</span>;</span><br><span class="line">        Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>, i = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(s.charAt(j))) &#123;</span><br><span class="line">                i = Math.max(map.get(s.charAt(j)), i);</span><br><span class="line">            &#125;</span><br><span class="line">            ans = Math.max(ans, j - i + <span class="number">1</span>);</span><br><span class="line">            map.put(s.charAt(j), j + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><ul><li>使用<code>char</code>数组代替<code>HashMap</code>，时间复杂度为<code>O(n)</code>，将会节省一定的空间，具体思路同<code>HashMap</code></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length(), ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] index = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">128</span>]; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>, i = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            i = Math.max(index[s.charAt(j)], i);</span><br><span class="line">            ans = Math.max(ans, j - i + <span class="number">1</span>);</span><br><span class="line">            index[s.charAt(j)] = j + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h4 id="问题：有一个整形数组arr和一个大小为k的窗口从数组最左边滑动到最右边，窗口每次滑动一个位置，返回每个窗口内的最大值组成的数组"><a href="#问题：有一个整形数组arr和一个大小为k的窗口从数组最左边滑动到最右边，窗口每次滑动一个位置，返回每个窗口内的最大值组成的数组" class="headerlink" title="问题：有一个整形数组arr和一个大小为k的窗口从数组最左边滑动到最右边，窗口每次滑动一个位置，返回每个窗口内的最大值组成的数组"></a>问题：有一个整形数组<code>arr</code>和一个大小为<code>k</code>的窗口从数组最左边滑动到最右边，窗口每次滑动一个位置，返回每个窗口内的最大值组成的数组</h4></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;滑动窗口是数组/字符串问题中常用的抽象概念。 窗口通常是在数组/字符串中由开始和结束索引定义的一系列元素的集合，即 [i, j)（左闭，右开）。而滑动窗口是可以将两个边界向某一方向“滑动”的窗口。例如，我们将 [i, j) 向右滑动 1 
      
    
    </summary>
    
      <category term="算法" scheme="http://blog.sangedon.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LeetCode" scheme="http://blog.sangedon.cn/tags/LeetCode/"/>
    
  </entry>
  
</feed>
