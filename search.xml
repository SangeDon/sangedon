<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>分布式锁的概念及实现</title>
      <link href="/2019/05/20/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%AE%9E%E7%8E%B0/"/>
      <url>/2019/05/20/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><blockquote><p>对于运行在同一个JVM中的单进程程序而言，要实现线程同步操作可使用语言和类库提供的锁，而对于如今分布在不同服务器上运行的程序而言，要实现线程同步操作，语言和类库提供的锁已不能满足需求，因此，对于此类场景，则可使用分布式锁。分布式锁的实现有多种形式，常见的主要有三种实现方式，如：基于数据库乐观锁；基于 redis 的 set 操作；基于 zookeeper 临时有序节点的特性</p></blockquote><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><h2 id="基于数据库实现"><a href="#基于数据库实现" class="headerlink" title="基于数据库实现"></a>基于数据库实现</h2><h3 id="基于数据库表"><a href="#基于数据库表" class="headerlink" title="基于数据库表"></a>基于数据库表</h3><blockquote><p>基于数据库的实现方式的核心思想是：在数据库中创建一个表，表中包含<strong>方法名（资源）</strong>等字段，并在<strong>方法名字段上创建唯一索引</strong>，想要执行某个方法，就使用这个方法名向表中插入数据，成功插入则获取锁，执行完成后删除对应的行数据释放锁。</p></blockquote><ul><li>创建被锁定方法或资源表</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`methodLock`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'主键'</span>,</span><br><span class="line">  <span class="string">`method_name`</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span> <span class="keyword">COMMENT</span> <span class="string">'锁定的方法名'</span>,</span><br><span class="line">  <span class="string">`desc`</span> <span class="built_in">varchar</span>(<span class="number">1024</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'备注信息'</span>,</span><br><span class="line">  <span class="string">`update_time`</span> <span class="built_in">timestamp</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">COMMENT</span> <span class="string">'保存数据时间，自动生成'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> <span class="string">`uidx_method_name`</span> (<span class="string">`method_name `</span>) <span class="keyword">USING</span> BTREE) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 <span class="keyword">COMMENT</span>=<span class="string">'锁定中的方法'</span>;</span><br></pre></td></tr></table></figure><ul><li>获取锁，锁定资源(方法或资源)</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> methodLock(method_name,<span class="keyword">desc</span>) <span class="keyword">values</span> (‘method_name’,‘<span class="keyword">desc</span>’)</span><br></pre></td></tr></table></figure><p>当要获取资源或执行某个方法时，向表中插入该方法记录，由于方法名为唯一索引，所以插入成功则表明已成功获取锁，否则失败</p><ul><li>释放锁</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> methodLock <span class="keyword">where</span> method_name =<span class="string">'method_name'</span></span><br></pre></td></tr></table></figure><p>当方法执行完毕时，删除插入的记录即可释放锁，其他进程中的线程即可通过插入记录获取锁</p><h3 id="基于数据库排他锁"><a href="#基于数据库排他锁" class="headerlink" title="基于数据库排他锁"></a>基于数据库排他锁</h3><blockquote><p>除了可以通过增删操作数据表中的记录以外，其实还可以借助数据中自带的锁来实现分布式锁。我们还用刚刚创建的那张数据库表，通过数据库的排他锁来实现分布式锁。主要 基于MySql的InnoDB引擎，当进行<code>for update</code>操作时，数据库会在查询过程中为当前查询添加排它锁</p></blockquote><ul><li>获取锁(加锁)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lock</span><span class="params">()</span></span>&#123;</span><br><span class="line">    connection.setAutoCommit(<span class="keyword">false</span>)</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">          <span class="comment">// 在查询语句后面增加`for update`，数据库会在查询过程中给数据库表增加排他锁</span></span><br><span class="line">            result = select * from methodLock where method_name=xxx <span class="keyword">for</span> update;</span><br><span class="line">            <span class="keyword">if</span>(result==<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是：InnoDB引擎在加锁的时候，只有通过索引进行检索的时候才会使用行级锁，否则会使用表级锁。如果我们需要使用行级锁，就要为method_name添加索引，并且一定要创建成唯一索引，否则会出现多个重载方法之间无法同时被访问的问题。重载方法的话建议把参数类型也加上。当某条记录被加上排他锁之后，其他线程无法再在该行记录上增加排他锁。</p><p>我们可以认为获得排它锁的线程即获得了分布式锁，当获取到锁之后，就可以执行方法的业务逻辑，执行完方法之后，再通过提交事物方法解锁：</p><ul><li>释放锁</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>&#123;</span><br><span class="line">    connection.commit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法可以有效的解决上面提到的无法释放锁和阻塞锁的问题。</p><ul><li><code>for update</code>语句会在执行成功后立即返回，在执行失败时一直处于阻塞状态，直到成功。</li><li>使用排它锁的方式，服务宕机之后数据库会自己把锁释放掉。</li></ul><h3 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h3><ol><li>无法直接解决数据库单点和可重入问题。</li><li>我们知道，Mysql执行查询语句之前会进行查询优化，因此，尽管我们对<code>method_name</code>使用了唯一索引，且使用<code>for update</code>来显示使用行级锁，但是查询时是否使用索引具体还要根据Mysql根据内部优化策略判断，如果数据量较小的时候，Mysql可能会认为全表扫描效率更高，则不会使用索引而导致InnoDB使用表锁，此时将导致需要获取其他锁的线程阻塞</li><li>如果某个事物长时间占用排它锁，导致长时间占用数据库连接，若类似的耗时连接较多，则数据库连接池将支持不住</li></ol><h3 id="可优化"><a href="#可优化" class="headerlink" title="可优化"></a>可优化</h3><ol><li>因为是基于数据库实现的，数据库的可用性和性能将直接影响分布式锁的可用性及性能，所以，数据库需要双机部署、数据同步、主从切换；</li><li>不具备可重入的特性，因为同一个线程在释放锁之前，行数据一直存在，无法再次成功插入数据，所以，需要在表中新增一列，用于记录当前获取到锁的机器和线程信息，在再次获取锁的时候，先查询表中机器和线程信息是否和当前机器和线程相同，若相同则直接获取锁；</li><li>没有锁失效机制，因为有可能出现成功插入数据后，服务器宕机了，对应的数据没有被删除，当服务恢复后一直获取不到锁，所以，需要在表中新增一列，用于记录失效时间，并且需要有定时任务清除这些失效的数据；</li><li>不具备阻塞锁特性，获取不到锁直接返回失败，所以需要优化获取逻辑，循环多次去获取。</li><li>在实施的过程中会遇到各种不同的问题，为了解决这些问题，实现方式将会越来越复杂；依赖数据库需要一定的资源开销，性能问题需要考虑。</li></ol><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><blockquote><p>基于数据库实现的两种方式都是依赖数据库的一张表，一种是通过表中的记录是否存在判断是否持有分布式锁，另一种是通过数据库的排他锁来实现分布式锁。</p><p><strong>优点</strong></p><p>直接借助数据库，容易理解。</p><p><strong>缺点</strong></p><p>有各种各样的问题，在解决问题的过程中会使整个方案变得越来越复杂。</p><p>操作数据库需要一定的开销，性能问题需要考虑。</p><p>使用数据库的行级锁并不一定靠谱，尤其是当我们的锁表并不大的时候。</p></blockquote><h2 id="基于Redis实现"><a href="#基于Redis实现" class="headerlink" title="基于Redis实现"></a>基于Redis实现</h2><blockquote><p>利用Redis的<strong>set命令</strong>。此命令是原子性操作，只有在key不存在的情况下，才能成功。</p></blockquote><ul><li>加锁</li></ul><p>最简单的方法是使用<strong>set</strong>命令。例如想要给一种商品的秒杀活动加锁，key 为 “lock_sale_商品ID” ，value 假设为 11，若 ret 为 1，则表示加锁成功，为 0 则表示已存在 key，加锁失败</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加锁伪代码</span></span><br><span class="line"><span class="keyword">int</span> ret = set（key，<span class="number">1</span>）;</span><br></pre></td></tr></table></figure><ul><li>解锁</li></ul><p>当获取锁的线程执行完毕，需要释放锁，通过 <code>del</code>操作删除记录，当所释放之后，其他线程即可通过 <code>set</code>操作获取锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 释放锁伪代码</span></span><br><span class="line">del(key)</span><br></pre></td></tr></table></figure><ul><li>锁超时</li></ul><p>当某个获取所得线程在释放锁之前挂掉，该锁将会长期被占用导致共享资源无法为其他线程提供服务，因此需要为锁添加超时时间，以保证在锁在超时占用时也能被正常释放，Redis 2.6.12 之前 set 操作无法设置超时时间，因此 加锁和设置超时时间的操作为非原子性操作，这会导致在极端情况下，某线程获取锁之后，设置超时时间之前挂掉的话，将无法释放锁。好在后面的版本中 set 操作可设置超时时间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加锁，设置超时时间 30s</span></span><br><span class="line"><span class="keyword">int</span> ret = set（key，<span class="number">1</span>，<span class="number">30</span>，NX）</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全过程伪代码如下</span></span><br><span class="line"><span class="keyword">if</span>（setnx（key，<span class="number">1</span>， <span class="number">30</span>， NX） == <span class="number">1</span>）&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">do</span> something ......</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        del（key）</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 以上代码还有一个问题，即若线程A超时时长内方法未执行完毕，其他线程（线程B）在此期间也获取到了锁，则A执行完毕后删除锁，而此时的锁为B的锁，为避免这种情况，在删除锁之前需要判断是否是自己添加的锁，则value可设置为当前线程ID</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 伪代码如下</span></span><br><span class="line"><span class="comment">// 加锁</span></span><br><span class="line">String threadId = Thread.currentThread().getId()</span><br><span class="line">set（key，threadId ，<span class="number">30</span>，NX）</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解锁</span></span><br><span class="line"><span class="keyword">if</span>（threadId .equals(redisClient.get(key))）&#123;</span><br><span class="line">    del(key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解锁操作中判断操作和解锁操作为非原子性操作，此时可通过lua代码来实现这一段代码</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String luaScript = <span class="string">"if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end"</span>;</span><br><span class="line"></span><br><span class="line">redisClient.eval(luaScript , Collections.singletonList(key), Collections.singletonList(threadId));</span><br></pre></td></tr></table></figure><p>此时已经解决了大部分问题，但是多个线程同步操作共享资源时，由于过期时间到达而方法未执行完毕，其他线程还是可以获取同步锁，可通过在获取同步锁的同时开启一个守护线程，例如 过期时间30s 则在29s时，将超时时间延长 一定的时间已达到续航的目的，但是需要注意的是，在方法执行完毕时，一定要手动关闭守护线程</p><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><blockquote><p>使用缓存来代替数据库来实现分布式锁，可以提供更好的性能，同时，很多缓存服务都是集群部署的，可以避免单点问题。并且很多缓存服务都提供了可以用来实现分布式锁的方法，比如redis的setnx方法等。并且，这些缓存服务也都提供了对数据的过期自动删除的支持，可以直接设置超时时间来控制锁的释放。</p><p><strong>优点</strong></p><p>性能好，实现起来较为方便。</p><p><strong>缺点</strong></p><p>通过超时时间来控制锁的失效时间并不是十分的靠谱。</p></blockquote><h2 id="基于zookeeper实现"><a href="#基于zookeeper实现" class="headerlink" title="基于zookeeper实现"></a>基于zookeeper实现</h2><blockquote><p>每个客户端对某个方法加锁时，在zookeeper上的与该方法对应的指定节点的目录下，生成一个临时有序节点。 判断是否获取锁的方式很简单，只需要判断有序节点中序号最小的一个。 当释放锁的时候，只需将这个临时节点删除即可。</p></blockquote><p>Zookeeper的数据结构就像一棵树，由节点（Znode）组成，节点分为四类，利用Zookeeper实现分布式锁主要使用其临时顺序节点的特性完成，节点分类及特性如下：</p><ul><li>持久节点</li></ul><p>默认的节点类型。创建节点的客户端与zookeeper断开连接后，该节点依旧存在 。</p><ul><li>持久顺序节点</li></ul><p>所谓顺序节点，就是在创建节点时，Zookeeper根据创建的时间顺序给该节点名称进行编号。</p><ul><li>临时节点</li></ul><p>和持久节点相反，当创建节点的客户端与zookeeper断开连接后，临时节点会被删除</p><ul><li>临时顺序节点</li></ul><p>临时顺序节点结合和临时节点和顺序节点的特点：在创建节点时，Zookeeper根据创建的时间顺序给该节点名称进行编号；当创建节点的客户端与zookeeper断开连接后，临时节点会被删除。</p><h3 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h3><ul><li>获取锁</li></ul><ol><li>在Zookeeper当中创建一个持久节点ParentLock。当第一个客户端想要获得锁时，需要在ParentLock这个节点下面创建一个<strong>临时顺序节点</strong> Lock1。</li><li>Client1查找ParentLock下面所有的临时顺序节点并排序，判断自己所创建的节点Lock1是不是顺序最靠前的一个。如果是第一个节点，则成功获得锁。</li><li>如果再有一个客户端 Client2 前来获取锁，则在ParentLock下载再创建一个临时顺序节点Lock2。</li><li>Client2查找ParentLock下面所有的临时顺序节点并排序，判断自己所创建的节点Lock2是不是顺序最靠前的一个，结果发现节点Lock2并不是最小的。</li><li>Client2向排序仅比它靠前的节点Lock1注册<strong>Watcher</strong>，用于监听Lock1节点是否存在。这意味着Client2抢锁失败，进入了等待状态。</li><li>如果又有一个客户端Client3前来获取锁，则在ParentLock下载再创建一个临时顺序节点Lock3。</li><li>Client3查找ParentLock下面所有的临时顺序节点并排序，判断自己所创建的节点Lock3是不是顺序最靠前的一个，结果同样发现节点Lock3并不是最小的。于是，Client3向排序仅比它靠前的节点<strong>Lock2</strong>注册Watcher，用于监听Lock2节点是否存在。这意味着Client3同样抢锁失败，进入了等待状态。</li><li>这样一来，Client1得到了锁，Client2监听了Lock1，Client3监听了Lock2。这恰恰形成了一个等待队列，很像是Java当中ReentrantLock所依赖的<strong>AQS</strong>（AbstractQueuedSynchronizer）。</li></ol><ul><li>释放锁</li></ul><p>释放锁分为两种情况：</p><ul><li><ul><li>任务完成，客户端显示释放</li></ul></li></ul><p>当任务完成时，Client1会显示调用删除节点Lock1的指令。</p><ul><li><ul><li>任务执行过程中，客户端崩溃</li></ul><p>获得锁的Client1在任务执行过程中，如果程序崩溃，则会断开与Zookeeper服务端的链接。根据临时节点的特性，相关联的节点Lock1会随之自动删除。</p></li></ul><p>由于Client2一直监听着Lock1的存在状态，当Lock1节点被删除，Client2会立刻收到通知。这时候Client2会再次查询ParentLock下面的所有节点，确认自己创建的节点Lock2是不是目前最小的节点。如果是最小，则Client2顺理成章获得了锁。</p><p>同理，如果Client2也因为任务完成或者节点崩溃而删除了节点Lock2，那么Client3就会接到通知。最终，Client3成功得到了锁。</p><h3 id="Zookeeper可解决问题"><a href="#Zookeeper可解决问题" class="headerlink" title="Zookeeper可解决问题"></a>Zookeeper可解决问题</h3><ul><li>使用Zookeeper可以有效的解决锁无法释放的问题，因为在创建锁的时候，客户端会在ZK中创建一个临时节点，一旦客户端获取到锁之后突然挂掉（Session连接断开），那么这个临时节点就会自动删除掉。其他客户端就可以再次获得锁。</li><li>使用Zookeeper可以实现阻塞的锁，客户端可以通过在ZK中创建顺序节点，并且在节点上绑定监听器，一旦节点有变化，Zookeeper会通知客户端，客户端可以检查自己创建的节点是不是当前所有节点中序号最小的，如果是，那么自己就获取到锁，便可以执行业务逻辑了。</li><li>使用Zookeeper也可以有效的解决不可重入的问题，客户端在创建节点的时候，把当前客户端的主机信息和线程信息直接写入到节点中，下次想要获取锁的时候和当前最小的节点中的数据比对一下就可以了。如果和自己的信息一样，那么自己直接获取到锁，如果不一样就再创建一个临时的顺序节点，参与排队。</li><li>使用Zookeeper可以有效的解决单点问题，ZK是集群部署的，只要集群中有半数以上的机器存活，就可以对外提供服务。</li></ul><h3 id="使用Zookeeper存在的问题"><a href="#使用Zookeeper存在的问题" class="headerlink" title="使用Zookeeper存在的问题"></a>使用Zookeeper存在的问题</h3><p>使用ZK实现的分布式锁好像完全符合了本文开头我们对一个分布式锁的所有期望。但是，其实并不是，Zookeeper实现的分布式锁其实存在一个缺点，那就是性能上可能并没有缓存服务那么高。因为每次在创建锁和释放锁的过程中，都要动态创建、销毁瞬时节点来实现锁功能。ZK中创建和删除节点只能通过Leader服务器来执行，然后将数据同步到所有的Follower机器上。</p><p>其实，使用Zookeeper也有可能带来并发问题，只是并不常见而已。考虑这样的情况，由于网络抖动，客户端可ZK集群的session连接断了，那么zk以为客户端挂了，就会删除临时节点，这时候其他客户端就可以获取到分布式锁了。就可能产生并发问题。这个问题不常见是因为zk有重试机制，一旦zk集群检测不到客户端的心跳，就会重试，Curator客户端支持多种重试策略。多次重试之后还不行的话才会删除临时节点。（所以，选择一个合适的重试策略也比较重要，要在锁的粒度和并发之间找一个平衡。）</p><h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><blockquote><p>优点**</p><p>有效的解决单点问题，不可重入问题，非阻塞问题以及锁无法释放的问题。实现起来较为简单。</p><p><strong>缺点</strong></p><p>性能上不如使用缓存实现分布式锁。 需要对ZK的原理有所了解。</p></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>上面三种方式，均无法在复杂性、可靠性、性能等方面无法同时满足，所以，我们需要根据不同的应用场景选择适合的实现方式。</p><ul><li>数据库实现容易理解，且易于实现，但是性能和可靠性方面较差</li><li>Zookeeper实现方式最难理解和实现，但是可靠性好</li><li>Redis实现方式性能较好，可靠性稍差与zookeeper</li></ul><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://mp.weixin.qq.com/s/8fdBKAyHZrfHmSajXT_dnA" target="_blank" rel="noopener">程序员小灰</a></p><p><a href="https://mp.weixin.qq.com/s/xcd8NWYMzpVJ3UKlGPIt9g" target="_blank" rel="noopener">Java后端技术</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式, 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>滑动窗口问题</title>
      <link href="/2019/05/20/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E9%97%AE%E9%A2%98/"/>
      <url>/2019/05/20/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p>滑动窗口是数组/字符串问题中常用的抽象概念。 窗口通常是在数组/字符串中由开始和结束索引定义的一系列元素的集合，即 [i, j)（左闭，右开）。而滑动窗口是可以将两个边界向某一方向“滑动”的窗口。例如，我们将 [i, j) 向右滑动 1 个元素，则它将变为 [i+1, j+1)（左闭，右开）。</p></blockquote><blockquote><h4 id="问题：给定一个字符串，请你找出其中不含有重复字符的-最长子串-的长度。"><a href="#问题：给定一个字符串，请你找出其中不含有重复字符的-最长子串-的长度。" class="headerlink" title="问题：给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。"></a><strong>问题</strong>：给定一个字符串，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</h4></blockquote><ul><li><p>暴力法</p></li><li><ul><li>比较暴力的方法，嵌套两次循环，时间复杂度为<strong>O(n^2</strong>)，具体思路为：使用一个双端队列，保存遍历到当前字符时不重复的字符串，下一个字符如果存在于队列中，则遍历到下一个字符时的子串长度为两个重复字符之间的距离，否则为上一个不重复子串长度加1</li></ul><p><strong>本方法适用于记录每一个不重复子串的求解，不适用于仅需要最长子串长度的求解</strong></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        LinkedList&lt;Character&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(s.charAt(<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &lt; s.length())&#123;</span><br><span class="line">            <span class="keyword">char</span> temp = s.charAt(index);</span><br><span class="line">            <span class="keyword">int</span> s1 = isInQueue(queue, temp);</span><br><span class="line">            <span class="keyword">if</span> (s1 &gt;= max)&#123;</span><br><span class="line">                max = s1;</span><br><span class="line">            &#125;</span><br><span class="line">            index ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回队列中与目标字符相同字符的距离，即遍历到当前字符时最长不重复长度</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">isInQueue</span><span class="params">(LinkedList&lt;Character&gt; queue, <span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">        LinkedList&lt;Character&gt; queueT = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">if</span> (queue.peekLast()!=c)&#123;</span><br><span class="line">                queueT.offer(queue.pollLast());</span><br><span class="line">                flag ++;</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">                    queue.poll();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!queueT.isEmpty())&#123;</span><br><span class="line">            queue.offer(queueT.pollLast());</span><br><span class="line">        &#125;</span><br><span class="line">        queue.offer(c);</span><br><span class="line">        <span class="keyword">return</span> flag + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用hash表记录不重复子串的字符，可分别使用<code>Set</code>和<code>Map or char[256]</code>字符数组</li><li><ul><li>使用<code>Set</code>， 时间复杂度为<strong>O(2n) —&gt; O(n)</strong>，通过使用 <strong>hash</strong>表作为滑动窗口，检查当前字符是否在不重复子串中仅需<strong>O(1)</strong>的时间，当前使用 <code>HashSet</code> 将字符存储在当前窗口<code>[i, j)</code>）中。 然后向右侧滑动索引 <code>j</code>，如果它不在 <code>HashSet</code> 中，我们会继续滑动<code>j</code>。直到<code>s[j]</code>已经存在于 <code>HashSet</code> 中。此时，找到的没有重复字符的最长子字符串将会以索引 <code>i</code>开头。当对所有的 <code>i</code> 这样做，就可以得到答案。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= j &amp;&amp; j &lt; s.length())&#123;</span><br><span class="line">            <span class="keyword">if</span> (!set.contains(s.charAt(j)))&#123;</span><br><span class="line">                set.add(s.charAt(j++));</span><br><span class="line">                max = Math.max(max, j - i);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                set.remove(s.charAt(i ++));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><ul><li>使用<code>HashMap</code>，时间复杂度为<code>O(n)</code>定义字符到索引的映射，而不是使用集合来判断一个字符是否存在。 当找到重复的字符时，可以立即跳过该窗口，也就是说，如果 <code>s[j]</code>在 <code>[i, j)</code>有与<code>j&#39;</code>的字符，我们不需要逐渐增加<code>i</code>以直接跳过<code>[i，j&#39;]</code>，并将<code>j&#39; + 1</code>。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length(), ans = <span class="number">0</span>;</span><br><span class="line">        Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>, i = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(s.charAt(j))) &#123;</span><br><span class="line">                i = Math.max(map.get(s.charAt(j)), i);</span><br><span class="line">            &#125;</span><br><span class="line">            ans = Math.max(ans, j - i + <span class="number">1</span>);</span><br><span class="line">            map.put(s.charAt(j), j + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><ul><li>使用<code>char</code>数组代替<code>HashMap</code>，时间复杂度为<code>O(n)</code>，将会节省一定的空间，具体思路同<code>HashMap</code></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length(), ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] index = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">128</span>]; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>, i = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            i = Math.max(index[s.charAt(j)], i);</span><br><span class="line">            ans = Math.max(ans, j - i + <span class="number">1</span>);</span><br><span class="line">            index[s.charAt(j)] = j + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Guns后台管理框架学习</title>
      <link href="/2019/05/20/Guns%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/"/>
      <url>/2019/05/20/Guns%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="官方简介"><a href="#官方简介" class="headerlink" title="官方简介"></a>官方简介</h2><blockquote><p>Guns基于SpringBoot 2，致力于做更简洁的后台管理系统。Guns项目代码简洁，注释丰富，上手容易，同时Guns包含许多基础模块(用户管理，角色管理，部门管理，字典管理等10个模块)，可以直接作为一个后台管理系统的脚手架! </p></blockquote><p>## </p><ul><li>下载</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 下载到指定文件夹</span><br><span class="line">localhost:IDEA-Workspace sangedon$ git clone https://github.com/stylefeng/Guns.git</span><br></pre></td></tr></table></figure><ul><li>部署</li></ul><p>通过<code>idea</code>导入，略</p><ul><li>启动</li></ul><img src="/2019/05/20/Guns后台管理框架学习/2019/05/20/Guns后台管理框架学习/1.png" title="启动">]]></content>
      
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FastDFS在Ubuntu上的安装及使用</title>
      <link href="/2019/04/22/FastDFS%E5%9C%A8ubuntu%E4%B8%8A%E7%9A%84%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8/"/>
      <url>/2019/04/22/FastDFS%E5%9C%A8ubuntu%E4%B8%8A%E7%9A%84%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><blockquote><p>libfatscommon 是 fastdfs 常用函数封装的库，需要从github上clone到本地编译安装，如果没有安装git需先安装。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 安装 git</span><br><span class="line">apt-get install git</span><br></pre></td></tr></table></figure><blockquote><p>下载安装libfastcommon</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 克隆项目</span><br><span class="line">git clone https://github.com/happyfish100/libfastcommon.git</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 进入目录</span><br><span class="line">cd libfastcommon/</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 编译</span><br><span class="line">./make.sh</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 安装</span><br><span class="line">sudo ./make.sh install</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 设置环境变量</span><br><span class="line">export LD_LIBRARY_PATH=/usr/lib64/</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 建立软连接</span><br><span class="line">ln -s /usr/lib64/libfastcommon.so /usr/local/lib64/libfastcommon.so</span><br></pre></td></tr></table></figure><blockquote><p>安装FastDFS</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 下载 FastDFS</span><br><span class="line">git clone https://github.com/happyfish100/fastdfs.git</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 进入目录</span><br><span class="line">cd fastdfs/</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 编译安装</span><br><span class="line">./make.sh &amp;&amp; ./make.sh install</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>暂时直接复制到目标目录，没有其他修改，相关配置可以在跑通后详细阅读和修改</span><br><span class="line">cp /usr/local/src/fastdfs/conf/http.conf /etc/fdfs/ #供nginx访问使用</span><br><span class="line">cp /usr/local/src/fastdfs/conf/mime.types /etc/fdfs/ #供nginx访问使用</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>配置文件准备(Notice: 根据本机的角色，按需复制粘贴配置文件!)</span><br><span class="line">cp /etc/fdfs/tracker.conf.sample /etc/fdfs/tracker.conf</span><br><span class="line">cp /etc/fdfs/storage.conf.sample /etc/fdfs/storage.conf</span><br><span class="line">cp /etc/fdfs/client.conf.sample /etc/fdfs/client.conf #客户端文件，测试用</span><br></pre></td></tr></table></figure><blockquote><p>获取 fastdfs-nginx-module</p><p>此 module 用于避免上传完成后，且 group storage 同步文件完成前，客户端从正在同步的主机处下载文件导致的出错</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/src</span><br><span class="line"></span><br><span class="line">git clone https://github.com/happyfish100/fastdfs-nginx-module.git --depth 1</span><br><span class="line"></span><br><span class="line">cp /usr/local/src/fastdfs-nginx-module/src/mod_fastdfs.conf /etc/fdfs</span><br></pre></td></tr></table></figure><blockquote><p>安装Nginx</p><ul><li>tracker 和 storage 均需要安装 nginx</li><li>对于 tracker, nginx 可以均衡负载到不同的 storage</li><li>对于 storage, nginx 可以提供反向代理，从而访问数据存储位置的文件</li><li>由于需要使用启用非默认 module , 故需要通过源码编译安装，不能使用 yum . 使用源码安装 nginx 的注意事项见《nginx - make install》</li></ul></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 安装nginx依赖环境</span><br><span class="line">apt-get install libpcre3 libpcre3-dev</span><br><span class="line">apt-get install zlib1g-dev</span><br></pre></td></tr></table></figure><ul><li>将下载好的nginx移动到Ubuntu自定义目录下</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 解压nginx</span><br><span class="line">tar -xvf nginx-1.14.1.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 进入nginx目录</span><br><span class="line">cd nginx-1.14.1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 预编译Nginx, 并指定nginx安装目录，增加fastdfs模块</span><br><span class="line">./configure --prefix=/usr/local/nginx --add-module=/home/sange/Downloads/fastdfs-nginx-module/src/</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 编译安装</span><br><span class="line"><span class="meta">$</span> make &amp;&amp; make install</span><br></pre></td></tr></table></figure><blockquote><ul><li>需要配置 nginx, tracker, storage 和 client</li><li>tracker 和 storage 需要搭配 nginx 使用，故在本教程中， nginx 的配置都是关于 tracker 和 storage 的，与 client 无关。</li><li>tracker, storage 和 client 都有自身的配置项，需要单独配置。</li></ul></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/fdfs/tracker.conf</span><br><span class="line"></span><br><span class="line">base_path=/home/yuqing/FastDFS</span><br><span class="line">改为:</span><br><span class="line">base_path=/home/dfs</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>将 tracker 和 storage 的 http.server_port 统一改为80可以正常访问，但是否最优方案，还需要观察</span><br><span class="line">http.server_port=8080</span><br><span class="line">改为:</span><br><span class="line">http.server_port=80</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS 7上Nginx的安装及基本配置</title>
      <link href="/2019/04/15/CentOS%207%E4%B8%8Anginx%E5%AE%89%E8%A3%85%E5%8F%8A%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE/"/>
      <url>/2019/04/15/CentOS%207%E4%B8%8Anginx%E5%AE%89%E8%A3%85%E5%8F%8A%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><em>Nginx</em> (engine x) 是一个高性能的<code>HTTP</code>和<code>反向代理</code>服务，也是一个<code>IMAP/POP3/SMTP</code>服务。由俄罗斯人伊戈尔·赛索耶夫为Rambler.ru站点用<strong>C语言</strong>开发的，第一个公开版本0.1.0发布于2004年10月4日，2011年成立同名公司，以提供支持。其源代码以BSD-like 许可证的形式发布，作为一款轻量级 Web/反向代理 服务器以及电子邮件（IMAP/POP3）代理服务器，其主要特点是每条连接占有内存少，并发能力强，常用于Web服务器、反向代理、负载均衡以及HTTP缓存等场景。</p><h2 id="编译安装-推荐"><a href="#编译安装-推荐" class="headerlink" title="编译安装(推荐)"></a>编译安装(推荐)</h2><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><h4 id="gcc"><a href="#gcc" class="headerlink" title="gcc"></a>gcc</h4><blockquote><p>安装 nginx 需要先将官网下载的源码进行编译，编译依赖 gcc 环境，如果没有 gcc 环境，则需要安装：</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install gcc-c++</span><br></pre></td></tr></table></figure><h4 id="PCRE-pcre-devel"><a href="#PCRE-pcre-devel" class="headerlink" title="PCRE pcre-devel"></a>PCRE pcre-devel</h4><blockquote><p>PCRE(Perl Compatible Regular Expressions) 是一个Perl库，包括 perl 兼容的正则表达式库。nginx 的 http 模块使用 pcre 来解析正则表达式，所以需要在 linux 上安装 pcre 库，pcre-devel 是使用 pcre 开发的一个二次开发库，nginx也需要此库。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y pcre pcre-devel</span><br></pre></td></tr></table></figure><h4 id="zlib"><a href="#zlib" class="headerlink" title="zlib"></a>zlib</h4><blockquote><p>zlib 库提供了很多种压缩和解压缩的方式， nginx 使用 zlib 对 http 包的内容进行 gzip ，所以需要在 CentOS上安装 zlib 库。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y zlib zlib-devel</span><br></pre></td></tr></table></figure><h4 id="OpenSSL"><a href="#OpenSSL" class="headerlink" title="OpenSSL"></a>OpenSSL</h4><blockquote><p>OpenSSL 是一个强大的安全套接字层密码库，囊括主要的密码算法、常用的密钥和证书封装管理功能及 SSL 协议，并提供丰富的应用程序供测试或其它目的使用。<br>nginx 不仅支持 http 协议，还支持 https（即在ssl协议上传输http），所以需要在 CentOS上 安装 OpenSSL 库。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y openssl openssl-devel</span><br></pre></td></tr></table></figure><ul><li>安装环境综合命令</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install gcc gcc-c++ autoconf automake zlib zlib-devel openssl openssl-devel pcre-devel</span><br></pre></td></tr></table></figure><h3 id="Nginx下载及安装"><a href="#Nginx下载及安装" class="headerlink" title="Nginx下载及安装"></a>Nginx下载及安装</h3><ul><li><a href="https://nginx.org/en/download.html" target="_blank" rel="noopener">官方下载地址</a></li><li>命令行下载</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -c https://nginx.org/download/nginx-1.14.1.tar.gz</span><br></pre></td></tr></table></figure><p>成功结果如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[sange@centos-7 java]$ wget -c https://nginx.org/download/nginx-1.14.1.tar.gz</span><br><span class="line">--2019-04-15 22:58:27--  https://nginx.org/download/nginx-1.14.1.tar.gz</span><br><span class="line">Resolving nginx.org (nginx.org)... 95.211.80.227, 62.210.92.35, 2001:1af8:4060:a004:21::e3</span><br><span class="line">Connecting to nginx.org (nginx.org)|95.211.80.227|:443... connected.</span><br><span class="line">HTTP request sent, awaiting response... 200 OK</span><br><span class="line">Length: 1014040 (990K) [application/octet-stream]</span><br><span class="line">Saving to: ‘nginx-1.14.1.tar.gz’</span><br><span class="line"></span><br><span class="line"><span class="meta">100%</span>[======================================&gt;] 1,014,040    210KB/s   in 4.7s   </span><br><span class="line"></span><br><span class="line">2019-04-15 22:58:33 (210 KB/s) - ‘nginx-1.14.1.tar.gz’ saved [1014040/1014040]</span><br></pre></td></tr></table></figure><h3 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf nginx-1.14.1.tar.gz</span><br></pre></td></tr></table></figure><h4 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">drwxr-xr-x. 6 sange sange   4096 Apr 15 23:16 auto   # </span><br><span class="line">-rw-r--r--. 1 sange sange 287441 Nov  6 21:52 CHANGES</span><br><span class="line">-rw-r--r--. 1 sange sange 438114 Nov  6 21:52 CHANGES.ru</span><br><span class="line">drwxr-xr-x. 2 sange sange    168 Apr 15 23:16 conf</span><br><span class="line">-rwxr-xr-x. 1 sange sange   2502 Nov  6 21:52 configure</span><br><span class="line">drwxr-xr-x. 4 sange sange     72 Apr 15 23:16 contrib</span><br><span class="line">drwxr-xr-x. 2 sange sange     40 Apr 15 23:16 html</span><br><span class="line">-rw-r--r--. 1 sange sange   1397 Nov  6 21:52 LICENSE</span><br><span class="line">drwxr-xr-x. 2 sange sange     21 Apr 15 23:16 man</span><br><span class="line">-rw-r--r--. 1 sange sange     49 Nov  6 21:52 README</span><br><span class="line">drwxr-xr-x. 9 sange sange     91 Apr 15 23:16 src</span><br></pre></td></tr></table></figure><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>使用默认配置即可，也可自定义配置</p><ol><li>使用默认配置</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 安装完成后nginx.conf等相关文件及目录即在 /usr/local/nginx 目录下</span><br><span class="line">[sange@centos-7 nginx-1.14.1]$ ./configure --prefix=/usr/local/nginx</span><br></pre></td></tr></table></figure><ol start="2"><li>自定义配置（不推荐）</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">./configure </span><br><span class="line"><span class="meta">#</span> 以下为’./configure‘ 命令的参数，’=‘后为各项参数的默认值</span><br><span class="line">--prefix=/usr/local/nginx  # Nginx安装路径。</span><br><span class="line">--conf-path=/usr/local/nginx/conf/nginx.conf  # 在没有给定-c选项下默认的nginx.conf的路径</span><br><span class="line">--sbin-path=/usr/local/nginx/sbin  # Nginx可执行文件安装路径。</span><br><span class="line">--pid-path=/usr/local/nginx/conf/nginx.pid  # 在nginx.conf中没有指定pid指令的情况下，默认的nginx.pid的路径</span><br><span class="line">--lock-path=/var/lock/nginx.lock  # nginx.lock文件的路径</span><br><span class="line">--error-log-path=/var/log/nginx/error.log  # 在nginx.conf中没有指定error_log指令的情况下，默认的错误日志的路径</span><br><span class="line">--http-log-path=/var/log/nginx/access.log  # 在nginx.conf中没有指定access_log指令的情况下，默认的访问日志的路径</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 其他参数含义，一般默认即可</span><br><span class="line">--with-*  # 表明启用某些功能模块</span><br><span class="line">--without-*  # 表明禁用某些功能模块</span><br></pre></td></tr></table></figure><h3 id="编译及安装"><a href="#编译及安装" class="headerlink" title="编译及安装"></a>编译及安装</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[sange@centos-7 nginx-1.14.1]$ sudo make &amp; make install</span><br></pre></td></tr></table></figure><h3 id="操作命令"><a href="#操作命令" class="headerlink" title="操作命令"></a>操作命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[sange@centos-7 nginx-1.14.1]$ whereis nginx  # 查找安装目录</span><br><span class="line">nginx: /usr/local/nginx</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 进入安装目录下的二进制执行文件目录进行相关操作</span><br><span class="line">[sange@centos-7 nginx-1.14.1]$ cd /usr/local/nginx/sbin/  </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 以下为nginx操作命令</span><br><span class="line">./nginx  # 启动 nginx</span><br><span class="line">./nginx -s stop  # 此方式相当于先查出nginx进程id再使用kill命令强制杀掉进程</span><br><span class="line">./nginx -s quit  # 此方式停止步骤是待nginx进程处理任务完毕进行停止</span><br><span class="line">./nginx -s reload  # 当修改 nginx.conf 后重新加载配置文件令其生效</span><br></pre></td></tr></table></figure><h3 id="开机自启动"><a href="#开机自启动" class="headerlink" title="开机自启动"></a>开机自启动</h3><p>即在<code>rc.local</code>增加启动代码就可以了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/rc.local</span><br></pre></td></tr></table></figure><p>增加一行 <code>/usr/local/nginx/sbin/nginx</code>，具体如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line"><span class="meta">#</span> THIS FILE IS ADDED FOR COMPATIBILITY PURPOSES</span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span> It is highly advisable to create own systemd services or udev rules</span><br><span class="line"><span class="meta">#</span> to run scripts during boot instead of using this file.</span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span> In contrast to previous versions due to parallel execution during boot</span><br><span class="line"><span class="meta">#</span> this script will NOT be run after all other services.</span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span> Please note that you must run 'chmod +x /etc/rc.d/rc.local' to ensure</span><br><span class="line"><span class="meta">#</span> that this script will be executed during boot.</span><br><span class="line"></span><br><span class="line">touch /var/lock/subsys/local</span><br><span class="line">/usr/local/nginx/sbin/nginx  # 增加的一行</span><br></pre></td></tr></table></figure><p>设置<code>rc.local</code>非root用户执行权限：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 755 rc.local</span><br></pre></td></tr></table></figure><h2 id="YUM安装"><a href="#YUM安装" class="headerlink" title="YUM安装"></a>YUM安装</h2><p>在CentOS下，yum源不提供nginx的安装，可以通过切换yum源的方法获取安装yum源，下例为官网的yum源。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo rpm -ivh http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm</span><br></pre></td></tr></table></figure><p>安装命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y nginx</span><br></pre></td></tr></table></figure><p>通过<code>whereis nginx</code>查看nginx默认安装路径</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/etc/nginx/  # Nginx默认配置路径，nginx.conf在此</span><br><span class="line">/var/run/nginx.pid  # PID目录</span><br><span class="line">/var/log/nginx/error.log  # 错误日志</span><br><span class="line">/var/log/nginx/access.log  # 访问日志</span><br><span class="line">/usr/share/nginx/html  # 默认站点目录</span><br></pre></td></tr></table></figure><p>测试命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nginx -t </span><br><span class="line"><span class="meta">#</span> 测试成功结果</span><br><span class="line">nginx: the configuration file /etc/nginx/nginx.conf syntax is ok</span><br><span class="line">nginx: configuration file /etc/nginx/nginx.conf test is successful</span><br></pre></td></tr></table></figure><p>开机自启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl enable nginx</span><br></pre></td></tr></table></figure><p>操作命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start nginx  # 启动服务</span><br><span class="line">sudo systemctl restart nginx  # 停止服务</span><br><span class="line">sudo systemctl reload nginx  # 重新加载配置</span><br></pre></td></tr></table></figure><p>yum卸载nginx命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum remove -y nginx</span><br></pre></td></tr></table></figure><h2 id="防火墙问题"><a href="#防火墙问题" class="headerlink" title="防火墙问题"></a>防火墙问题</h2><blockquote><p>因CentOS 7 防火墙未开放80端口导致本机不能成功访问虚拟机问题</p></blockquote><h3 id="CentOS-7-防火墙相关命令"><a href="#CentOS-7-防火墙相关命令" class="headerlink" title="CentOS 7 防火墙相关命令"></a>CentOS 7 防火墙相关命令</h3><p>查看已开放端口</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo firewall-cmd --list-ports</span><br></pre></td></tr></table></figure><p>开放<code>80</code>端口</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> ContOS 7 防火墙命令改为 `firewall`, 而7以下的防火墙命令为 `iptables`(且具体命令也不同)</span><br><span class="line">sudo firewall-cmd --zone=public --add-port=80/tcp --permanent</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 其他指令含义：</span><br><span class="line">–zone  #作用域</span><br><span class="line">–add-port=80/tcp  #添加端口，格式为：端口/通讯协议</span><br><span class="line">–permanent  #永久生效，没有此参数重启后失效</span><br></pre></td></tr></table></figure><p>设置完成之后需<strong>重启</strong>防火墙</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo firewall-cmd --reload  #重启firewall</span><br><span class="line">sudo systemctl stop firewalld.service  #停止firewall</span><br><span class="line">sudo systemctl disable firewalld.service  #禁止firewall开机启动</span><br></pre></td></tr></table></figure><h3 id="CentOS-7以下防火墙相关命令"><a href="#CentOS-7以下防火墙相关命令" class="headerlink" title="CentOS 7以下防火墙相关命令"></a>CentOS 7以下防火墙相关命令</h3><p>开放80端口</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo /sbin/iptables -I INPUT -p tcp --dport 80 -j ACCEPT</span><br></pre></td></tr></table></figure><p>保存</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo /etc/rc.d/init.d/iptables save</span><br></pre></td></tr></table></figure><p>查看开放的端口</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo /etc/init.d/iptables status</span><br></pre></td></tr></table></figure><p>开启与关闭防火墙</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 永久性生效，重启后不会复原</span><br><span class="line">sudo chkconfig iptables on  # 开启</span><br><span class="line">sudo chkconfig iptables off  # 关闭</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 即时生效，重启后复原</span><br><span class="line">sudo service iptables start  # 开启</span><br><span class="line">sudo service iptables stop  # 关闭</span><br></pre></td></tr></table></figure><ul><li><p>参考文章</p><p><a href="https://www.linuxidc.com/Linux/2016-09/134907.htm" target="_blank" rel="noopener">mafly</a></p><p><a href="https://blog.csdn.net/jack85986370/article/details/51169203" target="_blank" rel="noopener">Deep_Deep_Learning</a></p><p><a href="https://segmentfault.com/a/1190000014750417" target="_blank" rel="noopener">金武飞扬</a></p><p><a href="https://segmentfault.com/a/1190000018791822" target="_blank" rel="noopener">Guoye</a></p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
